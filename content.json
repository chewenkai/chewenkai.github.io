{"pages":[{"title":"","text":"18年7月校招进入腾讯后, 先后于*********团队工作, 19年加入到腾讯新闻工作至今, 除了负责新闻音频、视频、直播业务需求开发外, 主要工作于效率提升,工具建设, CI, 自动化等工作. 手机: ********** | Email: chewenkaich@gmail.com 个人信息 车文凯/男/1993 教育: 硕士/模式识别与智能系统 工作年限：4年 个人主页：chewenkai.github.io GitHub：github.com/chewenkai 工作经历2018年7月 ~ 至今 腾讯 北京1. 编译优化: 远程编译基于SSH和RSync实现一套远程编译方案, 通过AndroidStudio源码的阅读, Hook编译过程, 实现0配置远程编译. 节省本地机器资源约90%. 该项目已经参与到内部编译优化OTeam共建, 推进远程编译插件在各业务的协同, 团队使用率超过90%, 日使用次数超过500次. 2. 组件化和自动化 基于View树注册/解注册的消息分发和解耦方案 注解式的服务和Router 封装自动化工具成脚手架 流水线自动化发版本 3. 业务内容(腾讯新闻) 音频频道和TTS文章: 基于系统播放器的音频播放库的架构设计、开发和监控，实现音频缓存、分片播放功能，支持tts播放和预加载。 视频鉴权: 结合JsBridge开发腾讯视频预鉴权SDK, 用在手Q, 浏览器, 新闻等多个业务。 直播专项: 接入直播中台, 调通开发、发布流程, 支持直播专项需求迭代开发, 拆分需求, 评估工作量及梳理用例。 数据采集上报: 参与中台SDK开发，实现APP、页面、元素事件的自动化数据采集，对数据资产进行口径统一。用到APT、AOP插桩、gradle插件等。 4. 工具建设基于External Tools的工具集: 一键代理, 页面跳转, 布局开关, xlog解密等 文章和分享技术文章 关于Android远程编译的现状的综述(内部) 22.1 腾讯新闻GIT-LFS迁移全过程(内部) 22.1 基于MainFramer进行远程编译（以Android开发为例） 18.10 Android Studio的三种类型的模版(Templates)创建 19.3 演讲和讲义 GIT LFS 迁移：[如何给仓库瘦身] 远程编译：[笔记本编译时不再卡顿] 深入了解Android Studio [快捷键和模版的使用] 技能清单 Android开发：Kotlin/Java 脚本、文档和自动化部署工具：Shell 自动化/单元测试：solo/uiautomator/espresso/robolectric/JUnit IntelliJ 插件开发 奖项 Pixel based bruise region extraction of apple using Vis-NIR hyperspectral imaging , Computers and Electronics in Agriculture, 2018.（三区SCl论文，1F 2.201，第一作者） Application of Visible/Near Infrared Spectroscopy in the Prediction of Azodicarbonamide in Wheat Floury , Journal of Food Science, 2017.（ 三区SCl论文，IF 1.815,第一作者） 专利《一种基于移动设备的食品安全抽样过程监督管理装置》(第一作者)","link":"/about/index.html"}],"posts":[{"title":"4月第三周报告","text":"做小麦采样软件抽样单协议的变化原因 根据老师对软件的要求，分析出新需求与之前软件的差别： 要求给农民使用，所以不能存在被抽样单位，抽样单位等字眼，而这些在以前的抽样的里是固定死的。 要求能够最后添加一遍样品。之前抽样的只能对样品情况进行添加，与现在需求不符 要求可以添加病虫害的照片。之前每个抽样单中固定设置为只有一个单元格用于拍照，一个单元格录像和一个单元格定位。与现在需求不符 要求地理位置可以进行补充。 出现了新的单元格类型，比如二级单选单元格(type_radio_with_secondary_choice)，多选单元格(type_multi_select)，之前只有一级单选单元格。 之前抽样单存在的诟病 没有留下一个清楚的协议，后期需求变动时通过阅读代码分析协议。 抽样单部分的代码质量差，注释少。 以前的抽样单列表中显示的是样品编号和被抽样单位地址，在新软件中没有这两个选项","link":"/%E6%97%A5%E5%B8%B8%E6%B1%87%E6%8A%A5/4%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E6%8A%A5%E5%91%8A/"},{"title":"Android Studio的三种类型的模版(Templates)创建","text":"Android Studio的三种类型的模版(Templates)创建如果说使用快捷键是程序员的刀🔪，那灵活的使用代码模版就应该是程序员的剑。 这里说的模版(Templates)，是指在使用开发创建类文件，甚至是某些代码块时，IDE自动按照规定的格式创建出类或代码的功能。如果类中有大量相似代码，使用模版可以极大的提高开发效率，降低出错概率。 下面我们看一下如何在Android Studio上使用模版，我将讲述三种模版的创建，分别是： 使用Live Templates创建代码块模版 使用File and Code Templates创建类模版 基于FreeMarker创建多文件模版 1.代码块模版java中经常需要定义这样的静态常量： 1private static final int DEFAULT_VALUE = 1; 使用Live Templates后，就可以直接输入const就可以快速定义静态常量： 其设置方法是，打开File-&gt;Setting（⌘+,）,搜索“Live Templates”，打开如下的界面： 其中，1指的是缩写和该缩写的描述；2中输入的是模版的内容；3中可以指定该模版应用生效的语言和场所，例如，可以限制该模版只应用到Java语言定义变量(declaration)的时候; 4可以将模版中变化的部分定义为变量，如上图中的${name}和${value} 上面例子中的const是默认的模版，你可以点击加号添加自己的模版，例如为kotlin定义一个tag常量的模版： 2.创建类模版如果我经常创建Fragment，有些必填的步骤就可以放到模版里去 打开File-&gt;setting,找到File and Code Templates，打开如下页面： 点击加号创建新的类模版 在这填写模版的名字和生效的类型文件名 模版的内容，可变的部分用变量代替 举例一个简单的Fragment模版: 12345678910111213141516171819202122232425#if (${PACKAGE_NAME} != \"\")package ${PACKAGE_NAME};#endimport android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.fragment.app.Fragment;public class ${NAME} extends Fragment { private static final String TAG = \"${NAME}\"; public static ${NAME} newInstance() { return new ${NAME}(); } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.${layout}, container, false); }} 其中${NAME}代表的是类名变量，${layout}代表了资源文件名变量，这些变量在创建文件时会要求手动填入。 使用时，在文件夹上点击右键 new 的时候，就可以看到自己定义的模版了： 点击后，填写一下自定义的变量，就可以生成模版文件了： 上方的layout就是在定义模版时定义的变量，而NAME变量是系统预留变量，会被影射成File name这个名字。关于定义类模版的具体用法，可以参考设置中其他的模版，或者参考文档： https://www.jetbrains.com/help/idea/using-file-and-code-templates.html 一个小尾巴 这里顺便说一下如何定义类的作者信息模版：File and Code Template中有一个Includes标签，打开后是这个样子的： 这里填写一个模版，以后创建类的时候会自动把模版内容放在类名上方。一些像日期一样的变量可以在右下方查询。 3.创建多文件模版上面两种方法都是可以在设置中搞定的，比较好理解，下面这种就稍微复杂一点了。 相信大家肯定用File -&gt; new -&gt; Activity -&gt; EmptyActivity来创建一个新的页面，Android Studio会自动在manifest文件中注册Activity的名字，并创建好一个固定模版的Java和xml布局文件。 那么它是怎么实现的呢？我们可不可以像它一样也自定义创建多个不同类型的文件模版呢？答案是可以的。Android Studio使用的是Apache的FreeMarker模版引擎生成代码。 Android Studio将所有的这种模版的配置文件放在下面路径： Windows:{ANDROID_STUDIO_LOCATION}/plugins/android/lib/templates/ MacOS:Applications/Android Studio.app/Contents/plugins/android/lib/templates/ 可以看下它的目录结构： -activities -gradle -gradle-projects -other 可以看出它大致对不同类型的模版进行了简单的分类，下面我们以就以activities为例，看一下它是怎么做的。 打开activities-&gt;EmptyActivity文件夹，可以看到创建模版所涉及的几个主要文件/夹： 123456789├── globals.xml.ftl├── recipe.xml.ftl├── root│&nbsp;&nbsp; └── src│&nbsp;&nbsp; └── app_package│&nbsp;&nbsp; ├── SimpleActivity.java.ftl│&nbsp;&nbsp; └── SimpleActivity.kt.ftl├── template.xml└── template_blank_activity.png template.xml在template.xml文件中，定义的是一些模版需要用到的变量： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\"?&gt;&lt;template format=\"5\" revision=\"5\" name=\"Empty Activity\" minApi=\"9\" minBuildApi=\"14\" description=\"Creates a new empty activity\"&gt; &lt;category value=\"Activity\" /&gt; &lt;formfactor value=\"Mobile\" /&gt; &lt;parameter id=\"activityClass\" name=\"Activity Name\" type=\"string\" constraints=\"class|unique|nonempty\" suggest=\"${layoutToActivity(layoutName)}\" default=\"MainActivity\" help=\"The name of the activity class to create\" /&gt; ...// 省略一些参数// ... &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file=\"globals.xml.ftl\" /&gt; &lt;execute file=\"recipe.xml.ftl\" /&gt;&lt;/template&gt; 这里简单介绍几个重要的属性和标签： template中的name属性指定了该模版在Android Studio中显示的名字，如：File -&gt; new -&gt; Activity -&gt; EmptyActivity category标签指定了该模版放在Android Studio的那个分类中，如File -&gt; new -&gt; Activity -&gt; EmptyActivity。这里的分类名字可以自己指定。 parameter标签指定了该模版需要的参数，例如我在创建EmptyActivity时弹出的Wizard中的每一项其实都是在这里配置的(顺便说一下，标签配置的就是下图中的那个图片)： globals标签和execute标签分别制定了全局变量的配置文件和最核心的行为控制的文件(这里recipe.xml.ftl文件我也不知道应该叫什么，暂时这么称呼吧) recipe.xml.ftl这是整个配置的核心文件，如果template.xml文件是Android工程中的Layout布局文件，那recipe.xml.ftl就是java文件，它告诉Android Studio需要按照一定的顺序做一些逻辑工作，例如，创建文件，在IDE中打开文件等。下面我们看一下其内容： 1234567891011121314151617&lt;?xml version=\"1.0\"?&gt;&lt;#import \"root://activities/common/kotlin_macros.ftl\" as kt&gt;&lt;recipe&gt; &lt;#include \"../common/recipe_manifest.xml.ftl\" /&gt; &lt;@kt.addAllKotlinDependencies /&gt;&lt;#if generateLayout&gt; &lt;#include \"../common/recipe_simple.xml.ftl\" /&gt; &lt;open file=\"${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml\" /&gt;&lt;/#if&gt; &lt;instantiate from=\"root/src/app_package/SimpleActivity.${ktOrJavaExt}.ftl\" to=\"${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}\" /&gt; &lt;open file=\"${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}\" /&gt;&lt;/recipe&gt; 上面的&lt;#include/&gt;标签主要做了一些复用的工作，例如&lt;#include \"../common/recipe_manifest.xml.ftl\" /&gt;就是调用了recipe_manifest.xml.ftl文件在Manifest文件中插入了activity的信息。 我们主要关注下instantiate标签和open标签，这两句话翻译成自然语言就是： 根据模版文件：root/src/app_package/SimpleActivity.${ktOrJavaExt}.ftl生成类文件到${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}中去。 然后在Android Studio中打开文件：${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt} 如果需要同时生成多个文件，就需要在这里用instantiate标签生成。那么生成文件的模版是在哪里定义的呢？下面说的root文件夹就是。 root文件夹（模版文件夹）root指的是工程的代码根目录，其内部是src、res甚至AndroidManifest.xml.ftl这样跟工程目录对应位置的模版文件。我们以root/src/app_package/SimpleActivity.java.ftl文件为例，看下其模版是怎么定义的： 12345678910111213141516171819202122232425package ${packageName};import ${superClassFqcn};import android.os.Bundle;&lt;#if (includeCppSupport!false) &amp;&amp; generateLayout&gt;import android.widget.TextView;&lt;/#if&gt;public class ${activityClass} extends ${superClass} { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState);&lt;#if generateLayout&gt; setContentView(R.layout.${layoutName}); &lt;#include \"../../../../common/jni_code_usage.java.ftl\"&gt;&lt;#elseif includeCppSupport!false&gt; // Example of a call to a native method android.util.Log.d(\"${activityClass}\", stringFromJNI());&lt;/#if&gt; }&lt;#include \"../../../../common/jni_code_snippet.java.ftl\"&gt;} 可以看出，就是对一个Activity进行了模版化，其中很多变量提高了该模版的可扩展性，这里可以使用include引入其他模版的内容，或者使用if来进行条件判断，功能还是蛮强大的，更多的语法内容，可以参考FreeMarker模版引擎的文档： https://freemarker.apache.org/ 关于AndroidStudio的EmptyActivity模版创建分析就先到这里，下面我们实际的应用一下看看。 实战：创建列表Adapter模版背景目前做的工程中对RecycleView进行了封装，每次创建列表的Adapter时需要创建一系列文件才能开始写逻辑，这些文件包括： 列表的Adapter文件 数据Model的Pojo文件 列表中的View文件(ListItemView) View文件的layout文件 为了减少创建列表Adapter的工作量，按照下面步骤为其创建一套类似于EmptyActivity的模版： Step 1. 创建相关文件在第三节提到的Templates路径中的other文件夹下新建一个文件夹，随意命名为“ListAdapter”，然后在内部创建下面的文件目录： 123456789101112f├── globals.xml.ftlf├── recipe.xml.ftld├── rootd│&nbsp;&nbsp; ├── resd│&nbsp;&nbsp; │&nbsp;&nbsp; └── layoutf│&nbsp;&nbsp; │&nbsp;&nbsp; └── layout.xml.ftld│&nbsp;&nbsp; └── srcd│&nbsp;&nbsp; └── app_packagef│&nbsp;&nbsp; ├── Adapter.kt.ftlf│&nbsp;&nbsp; ├── ItemView.kt.ftlf│&nbsp;&nbsp; └── Model.kt.ftlf└── template.xml Step 2. 配置template.xml要想灵活的填写创建Adapter时涉及到的文件的名字，就要将这些名字参数化，在创建之前让程序员填写，这就需要在template文件中配置相应的参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\"?&gt;&lt;template format=\"5\" revision=\"1\" name=\"Create RecycleView Adapter\" minApi=\"9\" minBuildApi=\"14\" description=\"Create a RecycleView Adapter in DreamReader.\"&gt; &lt;category value=\"DreamReader\"/&gt; &lt;formfactor value=\"Mobile\" /&gt; &lt;parameter id=\"adapterName\" name=\"Adapter Name\" type=\"string\" constraints=\"class|unique|nonempty\" default=\"RecycleViewAdapter\" help=\"The name of the adapter of RecycleView\"/&gt; &lt;parameter id=\"layoutName\" name=\"Layout Name\" type=\"string\" constraints=\"layout|nonempty|unique\" default=\"view_list_item\" help=\"The name of the layout file of RecycleView\"/&gt; &lt;parameter id=\"itemViewName\" name=\"Item View Name\" type=\"string\" constraints=\"class|unique|nonempty\" default=\"ItemListView\" help=\"The name of the item list view class of RecycleView\"/&gt; &lt;parameter id=\"modelName\" name=\"Model Name\" type=\"string\" constraints=\"class|unique|nonempty\" default=\"ItemModel\" help=\"The name of the data model class of RecycleView\"/&gt; &lt;globals file=\"globals.xml.ftl\"/&gt; &lt;execute file=\"recipe.xml.ftl\"/&gt;&lt;/template&gt; 从上面可以看出，我们自定义了一个名字为DreamReader的category，并将该模版的名字命名为:Create RecycleView Adapter.然后添加了四个参数：adapterName，layoutName，itemViewName，modelName。最后制定了global文件和execute文件的名字。 Step 3.配置global文件global文件需要指定用到的全局变量，这里只需要用到src和res路径： 1234&lt;globals&gt; &lt;global id=\"srcOut\" value=\"${srcDir}/${slashedPackageName(packageName)}\" /&gt; &lt;global id=\"resOut\" value=\"${resDir}\" /&gt;&lt;/globals&gt; Step 4. 配置recipe文件recipe文件中写明了具体要进行的操作，指定了具体模版文件的路径和名字: 12345678910111213141516171819202122&lt;?xml version=\"1.0\"?&gt;&lt;#import \"root://activities/common/kotlin_macros.ftl\" as kt&gt;&lt;recipe&gt; &lt;instantiate from=\"root/src/app_package/Adapter.kt.ftl\" to=\"${escapeXmlAttribute(srcOut)}/${adapterName}.kt\" /&gt; &lt;open file=\"${escapeXmlAttribute(srcOut)}/${adapterName}.kt\" /&gt; &lt;instantiate from=\"root/src/app_package/Model.kt.ftl\" to=\"${escapeXmlAttribute(srcOut)}/${modelName}.kt\" /&gt; &lt;open file=\"${escapeXmlAttribute(srcOut)}/${modelName}.kt\" /&gt; &lt;instantiate from=\"root/src/app_package/ItemView.kt.ftl\" to=\"${escapeXmlAttribute(srcOut)}/${itemViewName}.kt\" /&gt; &lt;open file=\"${escapeXmlAttribute(srcOut)}/${itemViewName}.kt\" /&gt; &lt;instantiate from=\"root/res/layout/layout.xml.ftl\" to=\"${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml\" /&gt; &lt;open file=\"${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml\" /&gt;&lt;/recipe&gt; 上面代码生成(instantiate)了四个文件，并且让其全部在IDE中打开(open)。其中每个生成一个文件，都为其指定了具体的模版文件:Adapter.kt.ftl、Model.kt.ftl、ItemView.kt.ftl、layout.xml.ftl Step 5. 编写具体的模版文件下面贴出我写的具体的模版文件内容，由于我是用kotlin写的，所以后缀是kt.ftl，如果是java文件则应该是java.ftl后缀: Adapter.kt.ftl 123456789101112131415161718192021222324package ${escapeKotlinIdentifiers(packageName)}import android.content.Contextimport android.view.Viewimport android.view.ViewGroupimport com.tencent.news.pullrefreshrecyclerview.RecyclerViewAdapterEximport com.tencent.news.pullrefreshrecyclerview.RecyclerViewHolderExclass ${adapterName}(val context:Context) : RecyclerViewAdapterEx&lt;${modelName}&gt;() { private val TYPE_DEFAULT = 0 override fun getNormalItemType(position: Int): Int { return TYPE_DEFAULT } override fun getLayoutViewByViewType(parent: ViewGroup?, viewType: Int): View { return ${itemViewName}(context) } override fun bindData(holder: RecyclerViewHolderEx?, data: ${modelName}?, dataPos: Int) { (holder?.itemView as? ${itemViewName})?.setData(data, dataPos) }} 其中用到的变量名字都是在第二步中的template中定义的。 Model.kt.ftl 123package ${escapeKotlinIdentifiers(packageName)}data class ${modelName}(var name:String) ItemView.kt.ftl 12345678910111213141516171819202122232425package ${escapeKotlinIdentifiers(packageName)}import android.content.Contextimport android.util.AttributeSetimport android.view.LayoutInflaterimport android.widget.RelativeLayout&lt;#if applicationPackage??&gt;import ${applicationPackage}.R&lt;/#if&gt;import kotlinx.android.synthetic.main.${layoutName}.*class ${itemViewName} @JvmOverloads constructor(context: Context, attributeSet: AttributeSet? = null, defStyleAttributeSet: Int = 0) : RelativeLayout(context, attributeSet, defStyleAttributeSet) { init { LayoutInflater.from(context).inflate(R.layout.${layoutName}, this, true) } fun setData(data: ${modelName}?, index: Int) { }} layout.xml.ftl 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/sample_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/FrameLayout&gt; Step 6.使用重启Android Studio，这样，再写列表时，就可以一键生成上面四个文件了，在New列表中可以看到我们定义的category和name： 点击后，弹出填写参数的窗口: 框中的内容都是我们自定义的内容，可以在这里填入想要的文件名，点击finish就生成了相应的文件： 总结以上就是对Android Studio中模版用法的介绍和简单理解，可能有很多错误的地方，如有问题欢迎指正。本文主要讲了在Android Studio中创建Live Templates代码块模版、File and Code Templates类模版以及创建多文件模版，希望大家在工作中能巧用模版，提高效率。 除了Android Studio，其他JetBrain产品例如Intelli J、Clion、Pycharm等应该都是一样的，但是需要大家自己尝试一下，话说 Jetbrain真是在让程序员变懒这条路上一去不复返了😂。 参考[1] https://medium.com/androidstarters/mastering-android-studio-templates-ed8fdd98cb78 [2] https://riggaroo.co.za/custom-file-template-group-android-studiointellij/ [3] https://www.jetbrains.com/help/idea/using-file-and-code-templates.html [4] https://www.jetbrains.com/help/idea/using-live-templates.html [5] https://freemarker.apache.org/","link":"/uncategorized/android-studio%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E7%89%88-templates-%E5%88%9B%E5%BB%BA/"},{"title":"Android中动画的使用","text":"Android中动画的使用前言：在Android中，如果想让一个View的消失，如果没有做任何处理，直接setVisibility(View.GONE)，你会发现整个View是瞬间消失的，没有任何过度。为了让用户感知到View的消失，就要让这个View消失的时候带一个动画效果，这样可以减轻用户的焦虑感。 Android中动画的种类Android中共有三种动画系统，分别是： View Animations - 最原始的Android动画，性能差而且不够灵活.Property Animations动画出现后就被废弃了。 Property Animations - 自Android 3.0后引入的强大灵活的动画系统 Transition Animations - 上面两种动画只是对某个View进行改变，而不会影响其所在的容器及周边的Views，而Transition动画可以适应layout的变化。默认的Transition框架支持Andorid 4.4以上的系统，使用com.android.support:transition支持库可以使Transition框架兼容到Android 4.0及以上。 Property Animation 属性动画其中我们最常用的是Property animation，称之为，属性动画。顾名思义，属性动画可以对任意对象的任意属性在一段时长内进行渐变： Property animations allow us to animate any property of any object from one value to another over a specified duration. 所以，属性动画除了可以对View的位置、角度做变换外，还可以对字体的大小、View的颜色等属性进行变换。 Android中常用的动画叫Property Animation（属性动画），它是出现在View Animation(视图动画) （包括 Tween Animation（补间动画）和 Frame Animation(逐帧动画)） 之后的，相比老的视图动画，Property Animation的主要优势是： 老的View Animation只是对View对象的外观进行动画操作，但是并没有真正的改变对象本身的属性。例如对某个View平移以后，只是视觉特效，并没有真正改变这个View的位置，也就是说你点击平移后的View是不能触发onClick的，因为其属性中的位置还在原来的位置(the previous animations changed the visual appearance of the target objects… but they didn’t actually change the objects themselves.)。而Property Animation除了视觉效果，还能真正的改变View的属性。而使用Property Animation不仅可以对View进行透明度渐变、缩放、平移操作，还可以对其他的一些属性进行动画操作，例如字体大小，颜色，背景等，实现炫酷的字体颜色变化，或者背景颜色变化等等。 Property Animation（属性动画）的主要实现类是：ObjectAnimation。这个类是我们实现动画最常用的类。 ObjectAnimator 动画用法示例ObjectAnimator的主要用法如下，假设要让一个View进行透明度从透明到不透明： 1ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(view,\"Alpha\", 0f, 1f) .setDuration(getResources().getInteger(R.integer.china_date_switch_btn_gone_duration)); 上面代码中ofFloat就是指让这个动画按照float类型的精度去变化。ofFloat函数源码中的常用构造函数如下： 1ofFloat(Object target, String propertyName, float... values) 第一个target是要赋予动画的对象，第二个propertyName是赋予什么动画或者对这个对象的什么属性进行变化，第三个是一个可变长度的参数，那三个点表示这个参数可以有多个，例如上面示例代码中有两个，分别是0f和1f，表示从透明变到不透明。也可以添加任何多个，例如0f, 1f, 0.5f，指的就是从透明到不透明又到半透明。 上面简单的例子就实现了透明度动画。除了透明度属性，常用的属性还有： 常用的propertyName有以下： | 属性 | 作用 | 数值类型 | | ———— | ——————————— | ——– | | Alpha | 控制View的透明度 | float | | TranslationX | 控制X方向的位移（相对于当前位置） | float | | TranslationY | 控制Y方向的位移（相对于当前位置） | float | | ScaleX | 控制X方向的缩放倍数 | float | | ScaleY | 控制Y方向的缩放倍数 | float | | Rotation | 控制以屏幕方向为轴的旋转度数 | float | | RotationX | 控制以X轴为轴的旋转度数 | float | | RotationY | 控制以Y轴为轴的旋转度数 | float | 除了上面的属性，ObjectAnimator可以对一个对象的任意属性进行动画渐变，例如： 123ObjectAnimator.ofFloat(mTextView,\"textSize\", 0, 100, 50) .setDuration(5000) .start(); 这样就相当于不断调用TextView的setTextSize()方法对文字大小进行设置，就实现字体变大，再变小的动画。 但是需要注意的是，如果要对一个对象的属性进行变化，这个对象必须有公开的set的方法例如TextView有setTextSize这个方法，那么就可以用“textSize”这个属性。 这时你可能会疑惑了🤔，如果想控制的对象方法名字不是set开头，而是叫changeTextSize或者moveXPosition等，或者一个对象有set方法，但是没有public暴露给大家使用怎么办呢？ 这时可以提出两种抛砖引玉的方法： 在对象外层包装一个类，自己写一个public的set方法控制对象的属性。 使用ValueAnimator。至于什么是ValueAnimator，下面就马上会讲到。 ValueAnimator明白了怎么用，我们再简单了解一下它实现的原理，想一想怎样实现对象的属性动画呢？如果我们想实现一个1秒钟内将透明度从0变到1的动画，其实是把整个工作分成了两部分： 计算属性（透明度）的值。也就是这一秒内，每个时间点的属性值应该是多少，这部分工作由ValueAnimator完成。 设置属性（透明度）的值。将每个时间点的值设置到对象上。这部分由ObjectAnimator完成。 其实ValueAnimator就是一个时间机制，你甚至可以单纯的利用它的时间机制实现除了动画以外的其他逻辑： 123456789ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);anim.setDuration(500);anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { public void onAnimationUpdate(ValueAnimator animation) { Float value = (Float) animation.getAnimatedValue(); // do something with value... } });anim.start(); AnimatorSet如果需要组合多个动画，可以借助AnimatorSet进行统一管理。AnimatorSet类可以将单个的ObjectAnimator组合起来形成动画集，可以同时创建多个特效，例如，一边放大一边变透明化或者按照顺序先放大再透明化等等。通过组合不同的动画属性，可以满足生活中大部分常用的场景。其用法如下： 1234567891011121314ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(view,\"Alpha\", 0f, 1f) .setDuration(getResources().getInteger(R.integer.china_date_switch_btn_gone_duration));ObjectAnimator scaleAnim = ObjectAnimator.ofFloat(view,\"scaleY\", 0, 1) .setDuration(getResources().getInteger(R.integer.china_date_switch_btn_gone_duration));AnimatorSet fadeInAnim = new AnimatorSet();fadeInAnim.play(alphaAnim).with(scaleAnim);fadeInAnim.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animation) { super.onAnimationStart(animation); view.setVisibility(View.VISIBLE); }});fadeInAnim.start(); 两大神器TypeEvaluator和InterpolationTypeEvaluator恐怕不少刚接触ObjectAnimator的人都会想为啥ObjectAnimator后面要跟ofFloat, ofInt和ofObject，ofObject又是个什么东西呢？ 如果一个动画变化的属性是数字，例如透明度就是从0到1的，ofFloat会在要求的时间范围内把每个时间点的值计算成一个个的float值，相应的，ofInt就会把属性值计算成Int值，这些都是动画系统实现的方法。那如果现在属性的变化不是时间而是Point类，那动画系统怎么知道如何计算每个时间点的Point值呢，答案是你来告诉动画系统如何计算。只要继承TypeEvaluator类，实现其中的evaluate方法即可： 12345678public class PointEvaluator implements TypeEvaluator { public Object evaluate(float fraction, Object startValue, Object endValue) { Point startPoint = (Point) startValue; Point endPoint = (Point) endValue; return new Point(startPoint.x + fraction * (endPoint.x - startPoint.x), startPoint.y + fraction * (endPoint.y - startPoint.y)); }} 这样就可以计算两个点之间的值了： 123Point p0 = new Point(0, 0);Point p1 = new Point(100, 200);ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), p0, p1); Interpolation放大，缩小，平移等这样的动画方式非常普通，因为这些动画是线性的，也就是说在动画时间内，属性值的变化是线性变化的。大家有时会看到一些非常炫酷的动画例如，回弹，果冻效果等等，这些效果多是非线性变化的结果，如果想实现这样的效果，就用到了Interpolation（插值器）。 Android已经实现了常用的Interpolation，如： | Name | Description | | ———————- | ———– | | AccelerateInterpolator | 加速 | | BounceInterpolator | 弹跳 | | DecelerateInterpolator | 减速 | 还有AccelerateDecelerateInterpolator、AnticipateInterpolator、PathInterpolator、OvershootInterpolator、AnticipateOvershootInterpolator 、DecelerateInterpolator 、CycleInterpolator等，这些基本上涵盖了我们使用的范围。 当然，如果上面插值器不满足需求，也可以定制插值器，只需要继承BaseInterpolator并实现TimeInterpolator接口就可以了，例如OvershootInterpolator的实现： 123456789101112131415161718public class OvershootInterpolator extends BaseInterpolator { private final float mTension; public OvershootInterpolator() { mTension = 2.0f; } public OvershootInterpolator(float tension) { mTension = tension; } public float getInterpolation(float t) { // _o(t) = t * t * ((tension + 1) * t + tension) // o(t) = _o(t - 1) + 1 t -= 1.0f; return t * t * ((mTension + 1) * t + mTension) + 1.0f; }} 这里的getInterpolation方法里是一个插值器函数，如果输入的t直接返回，那这就是一个线性插值器。这个网站看一查看插值器函数生成的曲线，安利给大家。 Android Transition Framework上面介绍的动画针对的是某一个对象进行动画操作，但是实际应用中，我更多的使用Android的Transition动画来移动某个View。Transition动画与Property动画最大的区别就是：View动的过程中会对其周边的View产生影响。也就是说，如果我想让一个View逐渐变大，那它在变大的过程中不会覆盖在其周边的View上面，而是挤推着周围的View移动，也就是整个Layout都在变化，而这一切都是Transition框架自动实现的，开发者不需要关心实现细节。 后续补充： https://developer.android.com/training/transitions/ https://developer.android.com/training/transitions/start-activity https://cloud.tencent.com/info/8fb508a6e6115e59e4f151fbaadd432e.html 参考：ObjectAnimator 基本使用 http://wiki.jikexueyuan.com/project/android-animation/7.html Android 属性动画：这是一篇很详细的 属性动画 总结&amp;攻略 https://blog.csdn.net/carson_ho/article/details/72909894 为什么要废弃掉Android之前的动画？https://android-developers.googleblog.com/2011/02/animation-in-honeycomb.html 查看Interpolation曲线：http://inloop.github.io/interpolator/","link":"/uncategorized/android%E4%B8%AD%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Android面试相关知识点总结","text":"Android相关 Activity和Fragment的生命周期 加速Activity启动 精简onCreate中的代码 将耗时操作放到后台线程 优化布局文件（ Hierarchy Viewer， Layoutopt） 缓存ListView Android多线程的几种方式 Handler.sendXXXMessage() Handler.post(Runnable) Activity.runOnUIThread(Runnable) View.post(Runnable) AsyncTask 布局的优化 HierarchyViewer查看Layout层次 &lt;include&gt; 标签重用一些比较复杂的组件 &lt;merge&gt; 标签减少层次,避免嵌套过深的情况发生 使用ViewStub减少隐藏View的绘制 Android的几种缓存方法 内存缓存（使用LruCahe类，least recent used, 通过键值对的形式将对象储存在内存中，满了以后自动提出最不常用的对象） 磁盘缓存（使用DiskLurCache，数据库SQLite缓存，文件缓存） Android 屏幕适配两个重要单位： 密度无关像素(density-independent pixel, dp or dip):与终端上的实际物理像素点无关,可以保证在不同屏幕像素密度的设备上显示相同的效果。Android开发时用dp而不是px单位设置图片大小，是Android特有的单位。 独立比例像素(scale-independent pixel, sp or sip):Android开发时用此单位设置文字大小，可根据字体大小首选项进行缩放。屏幕适配要解决的问题： 使得“布局”、“控件”匹配不同的屏幕尺寸 使得“图片资源”匹配不同的屏幕密度 一个图片归纳解决办法,转自这里： 事件传递流程TODO 自定义View 继承View，至少自定义两个构造函数 重写onMeasure方法：widthMeasureSpec中指定模式UNSPECIFIED，EXACTLY，AT_MOST，MATCH_PARENT对应EXACTLY、WRAP_CONTENT对应AT_MOST 重写onDraw：使用canvas和Paint类做图。 在res/values/styles.xml自定义属性 Android OOM 处理原因：参考 单例造成的内存泄漏 (单例获取Activity的引用) 非静态内部类创建静态实例.(那为啥要用内部类？因为使用内部类能解决多继承问题) Handler造成的内存泄漏(静态+弱引用+removeCallbacksAndMessages) 线程造成的内存泄漏 图片的处理（压缩加缓存，压缩使用BufferedImage类） 资源未关闭造成的内存泄漏(BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap) 发现：参考 反复操作观察内存变化 通过代码检测Activity泄漏 利用工具检测，如LeakCanary adb shell dumpsys meminfo 通过Capture分析.hprof文件 处理： 图片处理优化 使用保守的Service （IntentSevice执行完任务后自动关闭） 当视图变为隐藏状态后释放内存 内存资源紧张时释放内存(onTrimMemory()回调方法) 使用优化后的数据容器(SparseArray) 知道内存的开销(类500字节, 实例12到16字节,char 16bits byte 8bits short 16bits int 32bits long 64bits float 32bits double 64bits) 性能的优化卡顿原因： 内存泄漏导致内存占用较高，导致JVM频繁触发GC UI线程做耗时任务 UI OverDraw 进程/线程间通信：参考1 参考2Linux上进程间通信: 套接口（Socket）, 管道（Pipe）,命名管道（named pipe）, 信号（Signal）, 信号量（semaphore）, 消息（Message）队列, 共享内存, 内存映射（mapped memory） Android的进程间通信大多基于Bindler，参见下面Binder机制。 Android中线程间通信：共享变量（Sharepreferrence），使用管道流（Pipes），handle机制，runOnUiThread(Runnable)，View.postDelay(Runnable) ，广播 Handler机制Handler，Looper，MessageQueue，Message，Messenger Binder机制TODO Volley机制（参考这里）通过一个RequestQueue维护所有网络请求。具体是： 1, RequestQueue的add函数接收到请求，判断其是否允许被缓存，如果不允许，则加入网络请求列队。 2, 如果允许缓存，则判断等待列队中是否有相同地址的请求，如果有，就加入等待列队，等待列队在每完成一次请求后访问，移除等待列队中相同的请求，并讲剩余的请求加入缓存列队。 3 如果没有相同的请求，则直接加入到缓存列队。缓存列队执行请求时先检查是否超时，如果超时则通过网络请求，如果未超时直接读取缓存。 GreenDao机制Picasso机制into会检查当前是否是在主线程上执行。 如果我们没有提供一个图片资源并且有设置placeholder，那么就会把我们设置的placeholder显示出来，并中断执行。 接下来就是创建了一个Request对象，我们在前面做得一些设置都会被封装到这个Request对象里面。 检查我们要显示的图片是否可以直接在缓存中获取，如果有就直接显示出来好了。 缓存没命中，那就只能费点事把源图片down下来了。这个过程是异步的，并且通过一个Action来完成请求前后的衔接工作。 进程保活 (参考这里)进程等级： 前台进程 (Foreground process) 可见进程 (Visible process) 服务进程 (Service process) 后台进程 (Background process) 空进程 (Empty process) 进程保活方法： 提供进程优先级，降低进程被杀死的概率 利用 Activity 提升权限 利用 Notification 提升权限(startForeground) 在进程被杀死后，进行拉活 利用系统广播拉活 利用第三方应用广播拉活 利用系统Service机制拉活(onStartCommand()中返回Service.START_STICKY) 利用Native进程拉活(利用 Linux 中的 fork 机制创建 Native 进程，在 Native 进程中监控主进程的存活，当主进程挂掉后，在 Native 进程中立即对主进程进行拉活) 利用账号同步机制拉活 四种启动模式android:launchMode=: standard(默认)、singleTop、singleTask、singleInstance FLAG: FLAG_ACTIVITY_NEW_TASK： 与singleTask相同。 FLAG_ACTIVITY_SINGLE_TOP： 与singleTop相同。 FLAG_ACTIVITY_CLEAR_TOP： 清空目标Activity上层所有Activity。如果未设置launchMode（即默认），会清空包括当前Activity及其上面的activites，然后重新创建目标Activity。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS： 具有这个标记的Activity不会出现在任务管理器的列表中，它等同于在XML中指定Activity的属性：android:excudeFromRecents=”true” 三种动画 帧动画 FrameAnimation:通过顺序的播放排列好的图片来实现 补间动画 TweenAnimation: 给出两个关键帧，在给定的时间内在两个关键帧间渐变(Alpha、Scale、Translate和Rotate)。 属性动画 Property Animation:插值器根据时间流逝计算当前属性值改变百分比以不断改变属性值。 Android长连接 客户端不断的查询服务器，检索新内容，也就是所谓的pull 或者轮询方式 客户端和服务器之间维持一个TCP/IP长连接，服务器向客户端push SMS的推送方式:服务器有新内容时，发送一条短信给客户端，客户端收到后从服务器中下载新内容 MVC和MVP模式 (参考)* Looper中的死循环// TODOJava相关 1. Java并发，线程相关什么是线程： 线程是一种轻量级进程，大多数情况下用于执行异步操作。 在一个Android 程序开始运行的时候，会单独启动一个进程，同时会产生一个UIThread线程（main线程）。 一个Android 程序默认情况下也只有一个进程，但一个进程下却可以有许多个线程。 默认的情况下，Service和Activity（还有Content Provider和Broadcast Receiver）会同时运行在进程的main线程中，是会相互阻塞的。线程和进程的区别： 地址空间:进程有自己独立的地址空间.进程至少有一个线程,进程内的所有线程共享进程的地址空间; 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源; 线程是处理器调度的基本单位,但进程不是. 线程只需要很少的资源就可“轻装上阵”运行的优点，来弥补进程并发的“颗粒度”粗糙的缺点，提高系统资源利用率。volatile和Synchronized区别: volatile: 它所修饰的变量不保留拷贝，直接访问主内存中的(保证可见性)。 synchronized: 保证在同一时刻最多只有一个线程执行该段代码(保证原子性)。 ReetrankLock与synchronized比较参考 synchronized阻塞同步，挂起线程和恢复线程的操作消耗性能大，ReentrendLock非阻塞同步,消耗小 ReentrendLock等待可中断，可实现公平锁，锁可以绑定多个条件。 原子性与可见性:(参考这里) 原子性： 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 可见性: 是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 Callable 和 Runnable 的区别: Runnable的run()没有返回值,Callable的call()有返回值,这个返回值具体是通过实现Future接口的对象的get方法获取的，这个方法是会造成线程阻塞的. Callable里面的call方法是可以抛出异常的，我们可以捕获异常进行处理 线程池的概念、好处、常见的线程池举例: 线程池的好处： 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。 有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞线程。 能对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。 Android中线程池源自Java的Executor接口。真正的线程池实现为ThreadPoolExecutor。 ThreadPoolExecutor它的构造方法提供了一系列参数来配置线程池。 corePoolSize：线程池核心线程数量 maximumPoolSize：线程池所能容纳的最大线程。 keepAliveTime：非核心线程的闲置超长时间，超过这个时间，非核心线程就会被回收。 unit：用于指定keepAliveTime参数的时间单位。 workQueue：线程池中的任务队列 threadFactory：线程工厂，为线程池提供创建新线程的功能。 线程池的分类 FixedThreadPool Executors.newFixedThreadPool方法创建。他是一种固定线程数量的线程池，只有核心线程。这些线程不会被回收。除非线程池被关闭。 CachedThreadPool Executors.newCachedThreadPool方法创建,它一种线程数量不固定的线程池。它只有非核心线程。并且它的线程都有超时机制，超过60秒闲置线程就会被回收。 ScheduledThreadPool Executors.newScheduledThreadPool方法创建，它的核心数量是固定的，而非核心数量没有限制。当非核心线程闲置是会立刻回收。 SingleThreadExecutor Executors.newSingleThreadExecutor方法创建，它只要一个核心线程，能确保所有任务都在一个线程中按顺序执行。它的意义在于统一所有的外界任务到一个线程中。是这些线程任务之间不需要处理线程同步的问题。 请解释sleep()和wait()区别？ sleep()是Thread类的定义方法，wait()是Object类定义的方法; sleep()可以设置休眠时间，时间一到自动唤醒，而wait()需要等待notify()进行唤醒 sleep()方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)； wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度 2. JVM内存空间分区（参考这里） 程序计数器(Program Counter Register): 程序计数器是当前线程所执行字节码的行号指示器 JVM栈(VM Stack): JVM栈用于存放正在执行的方法，每有一个函数被调用，就会创建一个栈帧压入JVM栈，方法执行完成后，将其栈帧从JVM栈中弹出。所谓的栈帧，就是存放当前方法中的存储局部变量、操作数栈、动态链接、方法出口等信息的一个东西。 本地方法栈(Native Method Stack): 本地方法栈与虚拟机栈所发挥的作用是类似的，其区别不过是本地方法栈则是为虚拟机使用到的native方法服务。 堆(Heap): java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。 方法区(Method Area): 是各个线程共享的内存区域，它用于存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 3. GC算法（参考这里）内存回收针对的是内存空间分区中的 堆 和 方法区 。 内存区域中的 程序计数器、虚拟机栈、本地方法栈 这3个区域随着线程而生，线程而灭，方法结束或者线程结束时，内存自然就跟着回收了，因此在这几个区域不需要过多考虑回收的问题。 引用计数算法： 老牌垃圾回收算法。无法处理循环引用，没有被Java采纳. 根搜索算法: 在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是标记-清除算法、复制算法、标记-整理算法。这三种算法都扩充了根搜索算法. 标记-清除算法： 通过根节点，标记所有从根节点开始的可达对象。在清除阶段，清除所有未被标记的对象。(缺点：1 效率比较低 2 清理出来的空闲内存不连续) 复制算法： 从根节点，将可达对象复制到新的内存空间中，然后清除原来的内存空间。（清理后的空间是连续的，但是此方法需要较大的内存空间） 标记-压缩算法： 标记步骤同标记-清除法，压缩是指移动所有存活的对象，且按照内存地址次序依次排列。最后将排列后末端内存地址以后的内存全部回收。（效率也不高） 4. Java中的强引用、软引用、弱引用和虚引用 目的： 对象的生命周期，以及利于 JVM 的垃圾回收 强引用： 如果一个对象具有强引用，它就不会被垃圾回收器回收。 软引用： 如果一个对象（如 s）只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 弱引用： 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 虚引用： 虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。 5. JAVA的多态(百度作业帮面试，融360面试)什么是多态 面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 多态的作用：消除类型之间的耦合关系。 现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 多态存在的三个必要条件 一、要有继承； 二、要有重写； 三、父类引用指向子类对象。 多态的好处： 1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。 2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。 3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。 4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。 5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。 6.static静态内部类与非静态内部类区别 静态内部类不需要有指向外部类的引用，但非静态内部类需要持有对外部类的引用 非静态内部类能够访问外部类的静态和非静态成员，静态类不能访问外部类的非静态成员，它只能访问外部类的静态成员 一个非静态内部类不能脱离外部类实体被创建,而静态内部类不需要外部类的对象就可创建。 7.Java中的修饰符访问修饰符（参考）public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不 仅可以跨类访问，而且允许跨包（package）访问。 private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以 及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、 属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 default: 即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访 问。 8.类的加载机制 (参考)双亲委派模型： 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。 自上而下的加载器顺序： Bootstrap ClassLoader(启动类加载器)，Extension ClassLoader(扩展类加载器)，Applicaiton ClassLoader(应用程序类加载器)，User ClassLoader（用户自己实现的加载器） 9. Java的注解原理// TODO 10. Java集合框架图 网络相关 http协议(参考这里)什么是http协议http协议是超文本传输协议，是一种基于请求与相应模式的、无状态的、应用层协议，常基于TCP的连接方式。 http协议特点http协议主要有以下五个特点： 支持客户/服务器模式 简单快速：客户想服务器请求服务时，只需要传递方法和路径，请求方法常用的有GET、HEAD、POST。由于HTTP协议简单，使得HTTP服务器程序规模小，因而通信速度快。 灵活：HTTP允许传输任意类型数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接含义是限制在每次连接只处理一个请求。服务器处理完客户请求，并收到客户应答后，即断开连接。 无状态：HTTP协议是无状态协议。协议对于事务没有记忆能力，缺少状态以为着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时应答会较快。http请求消息请求消息包括：请求行、消息报头、请求正文组成。 请求方法包括： GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求http响应消息HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文。 状态行：状态行由 HTTP 协议版本字段、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开; http请求/相应步骤以下是 HTTP 请求/响应的步骤： ● 客户端连接到web服务器：HTTP 客户端与web服务器建立一个 TCP 连接; ● 客户端向服务器发起 HTTP 请求：通过已建立的TCP 连接，客户端向服务器发送一个请求报文; ● 服务器接收 HTTP 请求并返回 HTTP 响应：服务器解析请求，定位请求资源，服务器将资源副本写到 TCP 连接，由客户端读取; ● 释放 TCP 连接：若connection 模式为close，则服务器主动关闭TCP 连接，客户端被动关闭连接，释放TCP 连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; ● 客户端浏览器解析HTML内容：客户端将服务器响应的 html 文本解析并显示; 在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP 连接; 6、浏览器将该 html 文本并显示内容; http协议状态码状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示： 1xx：表示服务器已接收了客户端请求，客户端可继续发送请求; 2xx：表示服务器已成功接收到请求并进行处理; 3xx：表示服务器要求客户端重定向; 4xx：表示客户端的请求有非法内容; 5xx：表示服务器未能正常处理客户端的请求而出现意外错误; 常见状态码描述文本有如下取值： 200 OK：表示客户端请求成功; 400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解; 401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用; 403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因; 404 Not Found：请求的资源不存在，例如，输入了错误的URL; 500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求; 503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常; Get与Post区别1.提交 GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接； POST提交：把提交的数据放置在是HTTP包的包体中。 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变 2.传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有： GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。 因此对于GET提交时，传输数据就会受到URL长度的 限制。 POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 3.安全性 POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为: 登录页面有可能被浏览器缓存； 其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了. 使用GET提交数据还可能会造成Cross-site request forgery攻击 4.Http get,post,soap协议都是在http上运行的 get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的 查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全 post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。 但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。 soap：是http post的一个专用版本，遵循一种特殊的xml消息格式 Content-type设置为: text/xml 任何数据都可以xml化。 ###http协议与https协议区别 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 http的连接很简单,是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全。 TCP协议TCP协议报头： ###URG ACK PSH RST SYN FIN字段作用 URG：紧急标志。紧急标志为”1”表明该位有效。 ACK：确认标志。表明确认编号栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号（w+1）为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。 PSH：推标志。该标志置位时，接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理。在处理Telnet或rlogin等交互模式的连接时，该标志总是置位的。 RST：复位标志。用于复位相应的TCP连接。 SYN：同步标志。表明同步序列编号栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端（一般是客户端）的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。 FIN：结束标志。 TCP三次握手连接 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 简单来说，就是 建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认 服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态 客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。 ###TCP四次挥手断开连接 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 Tcp为什么要三次握手，四次挥手一段通俗的解释 三次握手： A:“喂，你听得到吗？”A-&gt;SYN_SEND B:“我听得到呀，你听得到我吗？”应答与请求同时发出 B-&gt;SYN_RCVD | A-&gt;ESTABLISHED A:“我能听到你，今天balabala……”B-&gt;ESTABLISHED 四次挥手： A:“喂，我不说了。”A-&gt;FIN_WAIT1 B:“我知道了。等下，上一句还没说完。Balabala…..”B-&gt;CLOSE_WAIT | A-&gt;FIN_WAIT2（此处可能没有就是恰好B也发送完了，并且此处不在四次握手内，是正常通信的消息） B:”好了，说完了，我也不说了。”B-&gt;LAST_ACK A:”我知道了。”A-&gt;TIME_WAIT | B-&gt;CLOSED A等待2MSL,保证B收到了消息,否则重说一次”我知道了”,A-&gt;CLOSED TCP与UDP区别 基于连接与无连接； 对系统资源的要求（TCP较多，UDP少）； UDP程序结构较简单； TCP流模式与UDP数据报模式 ； TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。TCP、UDP的区别TCP是面向连接的，可靠的，传输大量数据，速度慢。UDP相反。TCP的三次握手、四次挥手 三次握手： 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误 四次挥手：TCP是全双工模式，这就意味着， 当主机1发出FIN报文段时，告诉主机2，它的数据已经全部发送完毕了,但是，这个时候主机1还是可以接受来自主机2的数据； 当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的； 当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了; 当主机1返回ACK报文段之后彼此就会愉快的中断这次TCP连接。HTTP的特点 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法(GET、HEAD、POST)和路径。 由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。HTTP与HTTPS的区别 算法相关（参考这里） 二位数组查找： 对数组进行排序，没一行从左到右递增，每一列从上往下递增。然后从右上角开始，比较与target的大小，如果等于，结束查找；如果大于target，则删除此列，如果小于target，删除此行；然后从剩下的数组右上角开始查找。 替换字符串中空格（替换数组中的元素x）： 先遍历一遍，统计字符串A中空格个数，然后计算替换后的总长度，生成新的长度的空字符串B。一个指针指向B的结尾，一个指向A的结尾，从后往前遍历A，遇到空格就在B中插入要替换的字符。 从尾到头打印链表（栈的使用）： 利用栈的先进后出原则 二进制中1的个数： 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。接着让原整数与减一后的数按位与（n &amp;=(n-1)），清除该数最右边的1，循环知道此数变为0. 数值的整数次方： a^n=a^(n/2)*a^(n/2)，(n为偶数)；或者 a^n = a^ ((n-1)/2)*a^((n-1)/2)*a，(n为奇数) 数据库相关 三范式即：属性唯一，记录唯一和表唯一 第一范式（1NF）：数据库表中的字段都是单一属性，不可再分。这个单一属性由基本类型构成，包括整数、实数、字符型、逻辑型、日期型等。 第二范式（2NF）：数据库表中不存在非关键字段对任意候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖任意组候选关键字。 第三范式（3NF）：在第二范式基础上，数据表中如果不存在非关键字段对任一候选字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y 数据库基本语法HAVING和WHERE对于分组查询的区别HAVING子句对GROUP BY子句设置条件的方式与WHERE子句和SELECT语句交互的方式类似。WHERE子句搜索条件在进行分组操作之前应用；而HAVING搜索条件在进行分组操作之后应用。HAVING语法与WHERE语法类似，但HAVING可以包含聚合函数。HAVING子句可以引用选择列表中出现的任意项。 Full outer join，left join, right join，inner join区别(参考这里)外连接1.概念：包括左向外联接、右向外联接或完整外部联接 2.左连接：left join 或 left outer join， 左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。 3.右连接：right join 或 right outer join。 右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 4.完整外部联接:full join 或 full outer join，完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 内连接1.概念：内联接是用比较运算符比较要联接列的值的联接 2.内连接：join 或 inner join，只返回符合条件的列。 交叉连接1.概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。 2.交叉连接：cross join 查询(更多语句参考此处) 查询数据库表最后一条记录(ID自增)1SELECT top 1 * FROM Table_Name ORDERBY ID DESC 1SELECT * FROM Table_Name WHERE ID=(SELECT MAX(ID) FROM Table_Name) 查询数据库表A中31-40条记录1SELECT top 10 * FROM A WHERE ID not in(SELECT top 30 ID FROM A) 查询员工平均工资大于3000的部门名称1SELECT Dept_Name FROM t_Dept WHERE ID in(SELECT Dept_ID FROM t_Salary GROUP BY Dept_ID HAVING avg(Salary)&gt;3000) 数据库相关 B树（百度作业帮面试）1.B树 Ｂ树及Ｂ－树，是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。 B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实作上。 1.1 B-树的性质M为树的阶数，B-树或为空树，否则满足下列条件： 1. 定义任意非叶子结点最多只有M个儿子；且M&gt;2； 2. 根结点的儿子数为[2, M]； 3. 除根结点以外的非叶子结点的儿子数为[M/2, M]； 4. 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 5. 非叶子结点的关键字个数=指向儿子的指针个数-1； 6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； 7. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 8. 所有叶子结点位于同一层； 如：（M=3） B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。 1.２ B树的运用场景 保持键值有序，以顺序遍历 使用层次化的索引来最小化磁盘读取 使用不完全填充的块来加速插入和删除 通过优雅的遍历算法来保持索引平衡 另外，B树通过保证内部节点至少半满来最小化空间浪费。一棵B树可以处理任意数目的插入和删除。 ２. B＋树 B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。 B+ 树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。 ２.1 B＋树的性质B+树是B-树的变体，也是一种多路搜索树，其定义基本与B-树同，除了： １. 非叶子结点的子树指针与关键字个数相同； ２. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）； ３. 为所有叶子结点增加一个链指针； ４. 所有关键字都在叶子结点出现； ２.２ B＋树与Ｂ树的区别1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 2. 不可能在非叶子结点命中； 3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 4. 更适合文件索引系统； B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找； ３. B*树B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针； B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）； B+树的分裂： 当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针； B*树的分裂： 当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针； 所以，B*树分配新结点的概率比B+树要低，空间使用率更高； 4 总结 B-树： 多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树： 在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树： 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3； 其他 了解哪些加密算法 (参考) 对称加密 ： DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES （归纳 DES, RC*, AES） 非对称加密: RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA Hash算法加密（不可逆向解密）：MD2、MD4、MD5、HAVAL、SHA","link":"/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/android%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"Git保命大全","text":"💥我不小心删除了分支 或者 删除了Stash 或者 丢失了提交（reset —hard） 怎么办！操作前，建议备份一下当前的分支，或者切换到新的分支进行操作。 1/ 确定正确的SHA-1值首先，你需要找到分支或者提交的SHA-1值，如果你已经知道丢失分支的SHA-1值，可跳过这个步骤。 通过git reflog命令查找对git作出过的修改，可以查询到HEAD的变更记录，如commit, rebase, checkout, reset等。示例如下： 12345678&gt;# git refloga55a2725e HEAD@{846}: checkout: moving from calvinche/3650/voiceopt to calvinche/3650/bugfix5271cecfc HEAD@{847}: commit: --story=855394891 【语音控制】语音控制功能优化5413bd7ce HEAD@{848}: checkout: moving from calvinche/3650/bugfix to calvinche/3650/voiceopta55a2725e HEAD@{849}: commit: --bug=74100899 【畅听页卡】活动弹窗遮挡播放列表的问题5413bd7ce HEAD@{850}: checkout: moving from calvinche/3650/voiceopt to calvinche/3650/bugfix5413bd7ce HEAD@{851}: reset: moving to 5413bd7ce1a1ddfbd12406175a83c863f9d68da6ff1200963 HEAD@{852}: commit: --story=855394891 【语音控制】语音控制功能优化 第一列就是所在提交的SHA-1值 如果通过reflog无法找到丢失的分支或者提交，那你还可以通过git fsck命令查找git数据库中所有丢失的分支信息： 1git fsck --full --no-reflogs --unreachable --lost-found | grep commit | cut -d\\ -f3 | xargs -n 1 git log -n 1 --pretty=oneline &gt; ~/lost-found.txt 由于输出的结果通常较大，我们一般将命令的输出重定向到一个文本文件中进行查看，其输出的结果如下所示： 123456e005fc257bb96252e9bc84deb255bba28f829e63 --story=854880635 【技术优化】升级gradle: 修复打包无产物b90bace85ba53c9a229f84a458935aeb6858bc6c --story=854880635 【技术优化】升级gradle: 修改build_patch失败9b51c859899d0699a73c699fb349d8ff952cf7ae WIP on master: c5312d039 Merge branch 'calvinche/dev/car_adapt' into 'master'aa0c44873d24bc07487e4e5b8883189573c55029 --story=64610857 【语音交互】播放控制功能:UI走查d40e8c2ed3122a30164c82696a72bf4d5fbd8c58 --story=854880635 【技术优化】升级gradle: 修复打包无产物ed0f98b6ebd7bb9bbb6da21467fdea2931bab598 --story=64610857 【语音交互】播放控制功能:实现语音识别和命令执行 然后我们就可以通过提交的名字或者通过git log -p &lt;commit&gt;查看提交的内容或git cat-file -p &lt;commit&gt;查看提交的信息来确定我们要恢复的提交，确定了要恢复的提交后，复制它的SHA-1值备用。 2/ 恢复如果你要恢复的是分支，使用类似于下面的命令： 1git checkout -b &lt;new branch name&gt; &lt;SHA-1&gt; 如果你要恢复的是提交，那么可以直接： 1git reset --hard &lt;SHA-1&gt; 💥我的提交历史重复臃肿，杂乱无章怎么办！有时候，在开发过程中，可能被产品或设计打断，或者前期考虑不够严谨导致后面补充了过多的修补提交，这时候可以通过Rebase的交互模式，对提交历史进行“美化”。 例如下面一个提交记录： 12345--story=854849047(d01f70f39)【技术优化】fresco图片库更新 hypertian* 2019-05-23 13:12--story=64746051 【个人中心】增加开机兴趣选择修改: UI走查修改1 calvinche 2019-05-20 22:25--story=64746051 【个人中心】增加开机兴趣选择修改: 产品补充逻辑1 calvinche 2019-05-23 15:59--story=64746051 【个人中心】增加开机兴趣选择修改: UI走查修改2 calvinche 2019-05-21 14:50--story=64746051 【个人中心】增加开机兴趣选择修改:产品补充逻辑2 calvinche 2019-05-23 18:25 可以看出，UI修改和逻辑修改提交了多次，这个时候如果把两个UI走查的提交合并，把两个补充逻辑的提交合并，提交历史看起来会清楚干净很多，于是，我们使用rebase操作来整理提交记录： 1/ 进入Rebase交互模式找到要修改提交的上一条提交的SHA值，如上面例子，要对下面四个提交进行修改，则需要找到”fresco图片库更新”这个提交的SHA值：d01f70f39，然后运行： 1git rebase -i d01f70f3 就进入到下面的页面： 12345678910111213141516171819202122232425262728pick 39741ee1a --story=64746051 【个人中心】增加开机兴趣选择修改: UI走查修改1pick 8078fa8f9 --story=64746051 【个人中心】增加开机兴趣选择修改: 产品补充逻辑1pick 6f830afa3 --story=64746051 【个人中心】增加开机兴趣选择修改: UI走查修改2pick 5efe76189 --story=64746051 【个人中心】增加开机兴趣选择修改:产品补充逻辑2# Rebase d01f70f39..5efe76189 onto d01f70f39 (4 commands)## Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup &lt;commit&gt; = like \"squash\", but discard this commit's log message# x, exec &lt;command&gt; = run command (the rest of the line) using shell# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# . create a merge commit using the original merge commit's# . message (or the oneline, if no original merge commit was# . specified). Use -c &lt;commit&gt; to reword the commit message.## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted. 2/ 使用合适的命令对提交记录进行修改每次提交按照时间升序排列，也就是最上面的提交是最早的提交。每个提交前面是要进行修改的命令，下面列出了所有可用的命令的名字及其功能，默认是pick，也就是保留这条提交，什么也不做的意思。这里解释一下几个常用的命令： reword：重命名提交信息 edit：编辑提交的内容，可以用于添加或移出提交的文件 squash：将当前提交和前一条提交合并，使用后，会跳到另一个页面，编辑合并后的提交信息 fixup：将当前提交和前一条提交合并，使用后，丢弃当前的提交信息，直接以上一条提交信息为合并后的提交信息 drop：删除当前的提交 ⚠️ 需要注意的是这句话： These lines can be re-ordered; they are executed from top to bottom. 意思是说，改变上面一行行的提交记录的顺序是可以改变最终的提交顺序的，不过需要注意的是，改变顺序可能会带来conflict，如果遇到冲突，需要解决冲突后才能继续Rebase。 可以看下视频中的演示消化理解 rebase interactively 3/ 恢复到Rebase前如果你rebase结束后发现并不是自己想要的结果，这个时候怎么恢复到rebase之前呢？很简单，运行下下面这个命令即可: git reset --hard ORIG_HEAD In case ORIG_HEAD is no longer useful, you can also use the branchName@{n} syntax, where n is the nth prior position of the branch pointer. So for example, if you rebase featureA branch onto your master branch, but you don’t like the result of the rebase, then you can simply do git reset --hard featureA@{1} to reset the branch back to exactly where it was before you did the rebase. You can read more about the branch@{n} syntax at the official Git docs for revisions. ⚠️⚠️⚠️ Rebase的最基本原则既然Rebase命令可以删除和编辑历史提交，那同样也有一个重要的原则： 永远不要对已经推到主干分支服务器或者团队其他成员的提交进行Rebase，我们选择Rebase范围应该在自己本地工作范围内。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。 参考：[1] https://www.internalpointers.com/post/squash-commits-into-one-git [2] https://ohshitgit.com/","link":"/uncategorized/git%E4%BF%9D%E5%91%BD%E5%A4%A7%E5%85%A8/"},{"title":"VIM常用命令","text":"VIM在命令行环境中（比如操作VPS）非常实用，习惯之后对工作效率\b的提高大有裨益。但是剑\b一天不用，锈的也是很快的。\b前几天在终端中偶然发现了命令vimtutor，\b该教程非常巧妙简洁，整个教程操作一遍只需要半个小时左右，基本的操作就很熟悉了。现在将其小节汇总\b于下，方便记忆。 浏览命令 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 h (左移) j (下行) k (上行) l (右移) 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt; 欲退出 Vim 编辑器，请输入 &lt;ESC&gt; :q! &lt;回车&gt; 放弃所有改动。 或者输入 &lt;ESC&gt; :wq &lt;回车&gt; 保存改动。 在正常模式下删除光标所在位置的字符，请按： x 欲插入或添加文本，请输入： i 输入欲插入文本 &lt;ESC&gt; 在光标前插入文本 A 输入欲添加文本 &lt;ESC&gt; 在一行后添加文本 特别提示：按下 键会带您回到正常模式或者撤消一个不想输入或部分完整 的命令。 删除和撤销 欲从当前光标删除至下一个单词，请输入：dw 欲从当前光标删除至当前行末尾，请输入：d$ 欲删除整行，请输入：dd 欲重复一个动作，请在它前面加上一个数字：2w 在正常模式下修改命令的格式是： operator [number] motion 其中： operator - 操作符，代表要做的事情，比如 d 代表删除 [number] - 可以附加的数字，代表动作重复的次数 motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)， $ 代表行末等等。 欲移动光标到行首，请按数字0键：0 欲撤消以前的操作，请输入：u (小写的u) 欲撤消在一行中所做的改动，请输入：U (大写的U) 欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 更改类命令 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。 更改类命令的格式是：c [number] motion 搜索、替换和跳转 CTRL-G 用于显示当前光标所在位置和文件状态信息。 G 用于将光标跳转至文件最后一行。 先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。 gg 用于将光标跳转至文件第一行。 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。 输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。 完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查 找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。 CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc 与外部的交互 :!command 用于执行一个外部命令 command。 请看一些实际例子： (MS-DOS) | (Unix) | comment —————-|—————— |————- :!dir | :!ls | - 用于显示当前目录的内容。 :!del FILENAME | :!rm FILENAME | - 用于删除名为 FILENAME 的文件。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 复制粘贴和插入 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。 输入大写的 O 可以在光标上方打开新的一行。 输入小写的 a 可以在光标所在位置之后插入文本。 输入大写的 A 可以在光标所在行的行末之后插入文本。 e 命令可以使光标移动到单词末尾。 操作符 y 复制文本，p 粘贴先前复制的文本。 输入大写的 R 将进入替换模式(\b相当于按下Insert键)，直至按 &lt;ESC&gt; 键回到正常模式。 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： ‘ic’ ‘ignorecase’ 查找时忽略字母大小写 ‘is’ ‘incsearch’ 查找短语时显示部分匹配 ‘hls’ ‘hlsearch’ 高亮显示所有的匹配短语 选项名可以用完整版本，也可以用缩略版本。 在选项前加上 no 可以关闭选项： :set noic 帮助 输入 :help 或者按 &lt;F1&gt; 键或 &lt;Help&gt; 键可以打开帮助窗口。 输入 :help cmd 可以找到关于 cmd 命令的帮助。 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 输入 :q 以关闭帮助窗口 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。按 &lt;TAB&gt; 可以使用一个补全。","link":"/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"初识ViewPager2","text":"ViewPager2是Google于2019年2月7号发布的ViewPager的升级版本，目前最新版本是1.0.0-alpha01。ViewPager2主要解决了传统ViewPager中的几个问题： 不支持从右到左布局 不支持纵向滚动 notifyDataSetChanged()有时不起作用的Bug 实现原理查看ViewPager2内部代码可以看出，其实现原理是在其内部封装了一个RecyclerView，利用LinearLayoutManager+PagerSnapHelper实现了ViewPager的滚动效果以及对纵向滚动的支持。 123456789101112131415public class ViewPager2 extends ViewGroup { private void initialize(Context context, AttributeSet attrs) { mRecyclerView = new RecyclerView(context) { ... }; mLayoutManager = new LinearLayoutManager(context); mRecyclerView.setLayoutManager(mLayoutManager); setOrientation(context, attrs); new PagerSnapHelper().attachToRecyclerView(mRecyclerView); ... }} 目前存在的问题：由于直接使用的RecycleView实现，一些ViewPager的特性没有得到完全实现，官方指出了下面几个问题： 不支持设置offscreen limit 与TabLayout的集成存在问题 FragmentStateAdapter还有稳定性问题 不支持设置pageWitch，默认100%/100% 不支持clipToPadding 不支持fakeDrag 设置page transformer时，不支持设置绘制顺序 使用方法：其使用方法与传统ViewPager类似： 1.在模块gradle中添加依赖： 1implementation 'androidx.viewpager2:viewpager2:1.0.0-alpha01' 2.在Layout文件中布局，这里可以设置滚动方向: 12345&lt;androidx.viewpager2.widget.ViewPager2 android:id=\"@+id/viewPager2\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" /&gt; 3.创建Adapter，ViewPager2使用FragmentStateAdapter来实现Fragment的管理： 1234567891011121314151617public class ViewPager2Adapter extends FragmentStateAdapter { public ViewPager2Adapter(@NonNull FragmentManager fragmentManager) { super(fragmentManager); } @NonNull @Override public Fragment getItem(int position) { return new SimpleFragment(); } @Override public int getItemCount() { return 10; }} 4.应用Adapter: 123viewPager2 = findViewById(R.id.viewpager2);ViewPager2Adapter adapter = new ViewPager2Adapter(getSupportFragmentManager());viewPager2.setAdapter(adapter); 总结ViewPager2具有原生支持垂直方向滑动的特性，但是由于目前FragmentStateAdapter还有稳定性问题，以及设置page transformer时，不支持设置绘制顺序，在实际应用时还需要多进行修改和测试。建议等官方推出稳定版本后，再考虑接入。 参考： [1] https://developer.android.com/jetpack/androidx/releases/viewpager2 [2] https://developer.android.google.cn/reference/androidx/viewpager2/adapter/FragmentStateAdapter [3] https://developer.android.google.cn/reference/androidx/viewpager2/widget/ViewPager2 [4] https://www.journaldev.com/26148/android-viewpager2","link":"/uncategorized/%E5%88%9D%E8%AF%86viewpager2/"},{"title":"新抽样单协议","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" $ More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/%E5%AD%A6%E4%B9%A0/%E6%96%B0%E6%8A%BD%E6%A0%B7%E5%8D%95%E5%8D%8F%E8%AE%AE/"},{"title":"坑--TextView同时使用maxLines&#x3D;1和ellipsize时偶发崩溃","text":"今天发现项目的报错记录中排名第一的是ArrayIndexOutOfBoundsException错误，影响用户84，发生次数129。 报错堆栈如下： 1234567891011121314151617181 android.text.StaticLayout.getLineTop(StaticLayout.java:878)2 android.widget.TextView.getExtendedPaddingTop(TextView.java:1966)3 android.widget.TextView.bringTextIntoView(TextView.java:7291)4 android.widget.TextView.onPreDraw(TextView.java:5107)5 android.view.ViewTreeObserver.dispatchOnPreDraw(ViewTreeObserver.java:944)6 android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2348)7 android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1292)8 android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:6598)9 android.view.Choreographer$CallbackRecord.run(Choreographer.java:800)10 android.view.Choreographer.doCallbacks(Choreographer.java:603)11 android.view.Choreographer.doFrame(Choreographer.java:572)12 android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:786)13 android.os.Handler.handleCallback(Handler.java:815)14 android.os.Handler.dispatchMessage(Handler.java:104)15 android.os.Looper.loop(Looper.java:194)16 android.app.ActivityThread.main(ActivityThread.java:5682)17 java.lang.reflect.Method.invoke(Native Method)18 java.lang.reflect.Method.invoke(Method.java:372) 从错误堆栈里并没有找到特别有用的信息。 于是去看了下报错的设备信息： | 机型设备 Top 5 | 系统版本 Top 5 | | ——————— | ——————————- | | 华为 TIT-TL00 11.26% | Android 5.1,level 22 31.40% | | 三星 GT-I908 26.48% | Android 4.1.2,level 16 20.48% | | 荣耀 CUN AL00 6.14% | Android 4.0.4,level 15 10.92% | | 华为 TAG-TL00 5.46% | Android 7.0 8.19% | | HTC T327T 4.44% | Android 4.0.3,level 15 7.85% | 可谓是五花八门，看来也不是特定机型或者特定系统的问题。 从日志和设备信息都分析不出问题，只能靠google了，通过不断的搜索，渐渐发现类似的崩溃跟TextView的两个属性有关系，分别是: Android:maxLines Android:ellipsize 根据查询的信息，得出了下面的结论： 如果同时设置了ellipsize和maxLine=1,就会在某些机型上产生崩溃（不是必先），报ArrayIndexOutOfBoundsException的异常。解决办法就是将maxLine=1换成已经废弃的singleLine=true。这是Android系统的一个bug，目前还没有解决。 下面查询到的相关记录： If you try to use maxLines=1 with ellipsize, you shall get the following lint error (refer to this discussion) Combining ellipsize and maxLines=1 can lead to crashes on some devices. Earlier versions of lint recommended replacing singleLine=true with maxLines=1 but that should not be done when using ellipsize 来源：https://code.luasoftware.com/tutorials/android/android-textview-singleline-with-ellipsis/ 问题 Crash when using ellipsize=”start” (Jelly Bean) 的回复 ri…@gmail.com ri...@gmail.com #3Jul 12, 2012 08:17AM I do notice that changing android:lines=”1” to android:singleLine=”true” causes the crash not to happen. 来源:https://issuetracker.google.com/issues/36950033 I faced what I suspect is the same problem in my own app. For me, it was happening because I was using android:ellipsize=\"start\" without also using android:singleLine=\"true\". We had switched all of our android:singleLine=\"true\" attributes to the recommended android:maxLines=\"1\", but it turns out that there’s a bug in how the system calculates the ellipsis that is triggered if singleLine isn’t present. So I believe you can solve this issue by simply adding android:singleLine=\"true\" to your TextViews that are using ellipsize attrs. 来源：https://stackoverflow.com/questions/45487427/crashlytics-reporting-multiples-issues-for-textview-makesinglelayout","link":"/uncategorized/%E5%9D%91-textview%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8maxlines-1%E5%92%8Cellipsize%E6%97%B6%E5%81%B6%E5%8F%91%E5%B4%A9%E6%BA%83/"},{"title":"在Ubuntu（Gnome桌面）设置StarDict词典的开启快捷键","text":"因为没找到 StarDict 的快捷打开/隐藏键，每次都要用鼠标点，觉得很不爽，于是找了一下，发现有个命令行版本，使用 StarDict 的词库。 12345678910111213sudo apt install sdcv$ sdcv -hsdcv - console version of StarDict.Usage: sdcv [OPTIONS] words-h, --help display this help and exit-v, --version display version information and exit-l, --list-dicts display list of available dictionaries and exit-u, --use-dict bookname for search use only dictionary with this bookname-n, --non-interactive for use in scripts--utf8-output output must be in utf8--utf8-input input of sdcv in utf8--data-dir path/to/dir use this directory as path to stardict data directory 然后在Ubuntu设置中找到 键盘 -&gt; 快捷键 -&gt; 自定义快捷键 ,添加一个快捷键命令: gnome-terminal --command sdcv ，即可通过快捷键启动一个终端查词了 词典界面如下： 1234567891011121314151617181920212223242526272829303132请输入单词或短语：苹果Found 1 items, similar to 苹果.--&gt;朗道汉英字典5.0--&gt;苹果apple【医】 apple相关词组: 苹果饼 苹果布丁 苹果酱 苹果酒 苹果渣 苹果汁 酸苹果 野生苹果请输入单词或短语：AppleFound 2 items, similar to Apple.--&gt;牛津现代英汉双解词典--&gt;apple/ˈæpl; `æpl/ n 1 (a) round fruit with firm juicy flesh and green, red or yellow skin when ripe 苹果: [attrib 作定语] an apple pie 苹果馅饼 * apple sauce 苹果酱. =&gt;illus at fruit 见fruit之插图. (b) (also `apple tree) tree bearing this fruit 苹果树. 2 (idm 习语) an/the ,apple of `discord (fml 文) cause of an argument or a quarrel 争端; 祸根. the ,apple of sb's `eye person or thing that is loved more than any other 心爱的人或物; 掌上明珠: She is the apple of her father's eye. 她是父亲的掌上明珠. in ,apple-pie `order very neatly arranged 井然有序.--&gt;朗道英汉字典5.0--&gt;apple*['æpl]n. 苹果, 家伙【医】 苹果请输入单词或短语 参考：http://liunian.info/tag/stardict（小居）","link":"/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E5%9C%A8ubuntu%EF%BC%88gnome%E6%A1%8C%E9%9D%A2%EF%BC%89%E8%AE%BE%E7%BD%AEstardict%E8%AF%8D%E5%85%B8%E7%9A%84%E5%BC%80%E5%90%AF%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"基于MainFramer进行远程编译（以Android开发为例）","text":"一、故事背景（可略过） 以前，世界上只有两种电脑：笔记本和台式机。 上帝说，要有高性能的笔记本。于是，就有了MainFramer。 我就遇到了这种情况，上班后公司配的是MacBookPro的笔记本和一个Windows的台式机（PC），我曾尝试过使用MacBook作为主力机工作，MacOS的体验非常优秀，但是唯一的不足就是其在处理大型复杂任务时的速度远不如我那台高配的台式机，编译一次工程的时间差在3分钟左右，而我每天编译上20次就能差出一个小时，有这个时间提前让我下班多好。最重要的是，我只要一点击Build，整个机器就开始满负荷运行，除了温度飙升外，CPU也被占满，这时候开个网页都卡成了幻灯片。 为了提高工作效率，我尝试一直用台式机工作，于是我的MBP吃灰了很久，这么优秀的笔记本放在那里吃灰实在是心疼。最关键的是，台式机让我完全没有工作流的感觉，当我周末无聊想充电的时候，我发现我所有想看的东西都在公司，当我一个个软件打开，一个个网页从历史记录中找到后，我发现我已经没有了学习的欲望。这时候我非常想念用笔记本时那种“合盖走人”后，回家打开盖子发现我所有的思路都还在的感觉。 于是我急切的找一种方法，让简单的任务在笔记本上来做，复杂的任务能够利用台式机完成，并且在体验上做到“无差别”。终于，我在浏览全球最大的同性社交网站时惊喜的发现了mainframer，这是一个工具，可以将编译这件占内存和CPU的事从本地电脑放到远程电脑上来做。 简单的说，你只需要一台本地机器（Local Machine：例如我的性能不咋地的MacBook）和一台远程机器（Remote Machine：性能强悍的台式机或者云主机），通过mainframer，就可以实现在本地机器上写代码，在远程机器上编译代码。你可以在笔记本上写代码，到了需要调试的时候，mainframer会快速同步代码到远程机器并进行编译，并将编译的结果返回到你的笔记本，这一切仿佛都是在你的笔记本上进行的，你可以正常的build和调试程序。这样一来，就可以享受笔记本的便捷，又能享受台式机的高性能了，美滋滋。 下面就是我配置成功后，录制的在MacBookPro上写代码，在Linux发行版Manjaro上进行Build的视频： 传送门 your browser does not support the video tag 目前该工具支持所有使用以下技术构建的代码： Gradle Gradle Android Rust Clang GCC Maven Buck Go 二、开始安装和配置mainframer的安装非常简单，以Android为例，你只需要： 下载mainframer到你工程的根目录下； 配置本地电脑和远程电脑的SSH； 根据不通类型的代码配置一下开发环境； 可以根据github上的readmen一步步的操作，有英文不好的小伙伴可以参考我实践的路子： 1.下载mainframer在这里下载mainframer的sh文件，放到Android工程的根目录下就可以了 2. 配置本地电脑和远程电脑的SSH2.1 配置SSH的目的是为了能让本地电脑直接运行ssh+远程电脑名字就可以进行ssh连接，避免中间复杂的输密码等过程，在配置前，你需要先了解远程电脑的三个参数： REMOTE_MACHINE_ALIAS — 远程电脑的名字，通常在Linux中是hostname，可以通过cat /etc/hostname查看，在mac上可以通过scutil --get ComputerName查看. REMOTE_MACHINE_IP_OR_HOSTNAME — 远程电脑的IP或者域名，如果是局域网内的电脑，则可能是192.168.XX.XX的形式，如果是云服务器可以直接填服务器地址如 42.42.42.42 or remote.domain.com. REMOTE_MACHINE_USERNAME — 远程电脑的用户名，这里官方建议在远程电脑新建一个用户（下面有脚本）来操作，这里可以现在就起一个名字，例如calvin。 后续教程中出现上面三个参数时，请替换为其正确的值。 2.2 知道了这三个参数，就可以开始配置了，首先配置本地电脑： 在本地生成ssh密钥： 1ssh-keygen -t rsa -b 4096 -C \"{REMOTE_MACHINE_USERNAME}\" //{REMOTE_MACHINE_USERNAME}替换为刚才起的用户名calvin 一路按回车就可以在~/.ssh/目录下生成公钥文件id_rsa.pub和私钥文件id_rsa. 配置本地SSH 开启SSH的ControlMaster并持久化socket连接，可以避免每次连接远程机器时重新建立连接，并可以省掉输入密码的过程，加速SSH命令的执行速度。具体操作为，打开~/.ssh/config(如果没有则创建一个新的)，并在里面输入： 1234567891011121314151617181920Host {REMOTE_MACHINE_ALIAS} User {REMOTE_MACHINE_USERNAME} HostName {REMOTE_MACHINE_IP_OR_HOSTNAME} Port 22 IdentityFile ~/.ssh/{SSH_KEY_NAME} PreferredAuthentications publickey ControlMaster auto ControlPath /tmp/%r@%h:%p ControlPersist 1h # 例如Host calvin User calvinche HostName 192.168.31.129 Port 22 IdentityFile ~/.ssh/id_rsa PreferredAuthentications publickey ControlMaster auto ControlPath /tmp/%r@%h:%p ControlPersist 1h 其中，{REMOTE_MACHINE_ALIAS}替换为远程机器的名字，{REMOTE_MACHINE_USERNAME}替换为远程机器的用户名，{REMOTE_MACHINE_IP_OR_HOSTNAME}替换为远程机器的IP或域名，{SSH_KEY_NAME}替换为上一节说的在本地生成ssh私钥文件的名字，其位置位于~/.ssh/下，名字一般为id_rsa。 2.3 下面登陆远程机器，进行配置： 在远程电脑上创建新用户{REMOTE_MACHINE_USERNAME}，并将配置公钥，这里可以直接通过官方脚本进行操作，将脚本remote_machine_setup.sh下载到远程服务器并这样运行： 1remote_machine_setup.sh {REMOTE_MACHINE_USERNAME} \"引号内将刚才生成的公钥文件中的内容复制过来\" 这里的REMOTE_MACHINE_USERNAME就是在远程机器上新建的用户，这样如果几个人共用一台远程服务器来写一个工程就不会讲代码混淆在一起了。 执行后若显示New user $NEW_USER was set up correctly就说明创建成功了。 通过输入 ssh 远程机器的用户名 如ssh calvin来验证是否能够顺利登陆到远程机器，如果不需要输密码就能登陆成功，那么就可以了，如果出现:Permission denied (publickey,password)这样的话就说明远程机器的公钥与本地不符，或者本地ssh的config文件中私钥的名字不正确，需要认真检查。 到这里，基本上就完成了mainframer的配置工作，可以通过运行下面代码测试能否工作： 1bash ./mainframer.sh echo \"I am Calvin\" &gt; success.txt 如果本地的success文件中的内容如下图所示，那么整个流程就跑通了。 如果您是Android开发的话，可以通过命令 ./mainframer ./gradlew build 进行远程编译了。 如果你还想再进一步，把该工具添加到开发环境中，实现无缝隙的远程编译，可以根据背景一节中列出的不同的开发的链接查看教程，下面以Android为例，介绍怎么将其接入到Android Studio中，实现，点击调试按钮，自动远程编译。 3. 根据不通类型的代码配置开发环境（以Android为例）打开Android Studio， 按照下面步骤进行配置： 点击Run → Edit Configuration → +. 选择 Android App. 起一个好一点的名字, 例如remote-build. 在Module中选择要编译的模块名字，如app. 在Before Launch只点击减号删除原来的 Gradle-aware Make 在Before Launch只点击+号创建一个 Run External Tool. 填个好一点的名字，如remote assembleDebug. Program里填bash. Parameters里填mainframer.sh ./gradlew :app:assembleDebug -Pandroid.enableBuildCache=true Working directory里填$ProjectFileDir$. 示意图： 整个操作就完成了，可以愉快的玩耍了。很开心，是不是？ 三、填坑坑No.1 环境变量问题第二节中的安装方法是根据mainframer的github仓库Readme进行的尝试，事实上安装和配置完成后也不是那么一帆风顺，点击编译后的遇到一个找不到SDK位置问题： 123* What went wrong:A problem occurred configuring project ':app'.&gt; SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable. 但是我在远程机器中添加了ANDROID_HOME变量，如下，但还是报错 12echo $ANDROID_HOME/opt/android-sdk 经过一轮搜索发现，原来mainframe使用的ssh登陆的shell是non-interactive的，在这种模式下，无法读取你定义在~/.bashrc /etc/bashrc /etc/profile等文件中的变量 最终，有两种方法可以解决找不到环境变量的问题： 第一种，配置~/.ssh/environment方法： 你需要通过下面方式，配置SDK的位置和JAVA的位置： 首先，打开远程机器的SSHD配置文件，运行：sudo vim /etc/ssh/sshd_config.在打开的文件中查找这一行# PermitUserEnvironment no，并将其改成PermitUserEnvironment=yes 然后在~/.ssh目录下创建environment文件：vim ~/.ssh/environment，并将变量以key=value的形式写入，例如我的配置文件为： 12ANDROID_HOME=/home/calvinche/Android/SdkJAVA_HOME=/home/calvinche/Android/jdk1.8.0_181/ 这样，本地机器通过ssh登陆后就能正确找到sdk和java的位置了。 不过该方法不能像Shell一样用path=path:/home/...这种语法，所以只能访问到你配置的这几个有限的地址，很多命令还是没法使用。如果你的gradle脚本中使用了jar命令，那么还会提醒你找不到文件，所以建议使用下面的方法。 第二种，加载完整的远程环境变量： 在上一节的第3步中（3. 根据不通类型的代码配置开发环境（以Android为例）），在Parameters中运行的自定义命令前，加载一下远程机器的环境配置文件，命令如下： source /etc/profile 例如我的配置为： mainframer.sh \"source /etc/profile &amp;&amp; bash ./gradlew :app:assembleLocal_Debug --stacktrace\" 坑No.2 Before launch中总是自动添加Gradle-aware Make遇到的第二个问题就是在Debug Configuration中的Before launch，我只是添加了自定义的一个external tool，但是经常发现Android Studio会自动给我加上Gradle-aware Make，导致每次远程编译结束又开始本地编辑一遍。 出现这个问题的原因是Android Studio发现before launch里没有Gradle-aware Make会以为软件出了问题，进而进行了自动修复，这个问题的解决办法就是修改Android Studio的配置文件，让它不要自动修复： 打开Android Studio的选项卡Help，找到Edit Custom VM Options选项，打开后出现一个叫studio的文件 在文件的最后添加一行:-Dgradle.ide.gradle.run.configuration.fix.enabled=false 用了一段时间了，暂时就发现这两个问题，❤️ 四、讨论Mainframer很好的中和了我手中Mac笔记本的低配置和Windows台式机的不便携，将Mac的轻薄、便携和Windows的高配较好的结合起来。使我愉快的在使用小尺寸mac的同时，能得到最高的工作效率。但是这只是Mainframer的一个小领域应用，其实Mainframer可以用在更多实用的地方，比如使用集群作为远程机器，让大家可以连接进行远程编译等等。大家有什么想法，欢迎积极留言交流哈。","link":"/%E5%B7%A5%E5%85%B7/%E5%9F%BA%E4%BA%8Emainframer%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E7%BC%96%E8%AF%91%EF%BC%88%E4%BB%A5android%E5%BC%80%E5%8F%91%E4%B8%BA%E4%BE%8B%EF%BC%89/"},{"title":"对Lamda表达式的简单理解","text":"第一次见Lamda表达式第一次看到这行代码的时候，我是百思不得姐： 1Toolkit.let(mUserTabFragment, f -&gt; f.setUserVisibleHint(true)); 点击进入let函数看到其定义如下： 123456public static &lt;T&gt; void let(@Nullable T input, Consumer&lt;T&gt; consumer) { if (input == null || consumer == null) { return; } consumer.accept(input);} 可以看出let的第二个参数是一个Consumer，但是上面的f-&gt;f.setUserVisibleHint(isVisibleToUser));是什么鬼，是Consumer吗？答案是 是的，这样看就明白了，首先，我们创建一个Consumer对象： 123456Consumer&lt;Fragment&gt; consumer = new Consumer&lt;Fragment&gt;() { @Override public void accept(Fragment f) { f.setUserVisibleHint(true)); }}; 上面代码的Lamda形式为： 1Consumer&lt;Fragment&gt; consumer = (f)-&gt; f.setUserVisibleHint(true)); 所以 可以直接将等号右边带入let函数的第二个参数，就变成了那个样子： 1Toolkit.let(mUserTabFragment, f -&gt; f.setUserVisibleHint(true)); 现在应该就明白了第二个参数到底是啥了，其实就是一种Lamda表达式。 函数式接口(Functional Interface)那么到底什么是Lamda表达式呢？在使用Java的Lamda表达式之前，有一个重要的概念，叫函数式接口： 函数式接口(Functional Interface)就是有且仅有一个方法的接口 例如我们平时经常用到的Callable, Runnable都是函数式接口，在这里的Consumer也不例外，Consumer也是java1.8版本新增的函数式接口，与Runnable和Callable一样。假如你想定义一个回调，这个时候你又不像去专门定义一个回调接口On，就可以用Runnable或Callable等这样的接口实现： 12345678910111213141516171819class A{ B b = new B(); void doHere(){ // b.runnable = new Runnable() {// @Override// public void run() {// System.out.println(\"Do something here.\");// }// }; 这段注释代码是不用lamda表达式的形式 b.runnable = ()-&gt; System.out.println(\"Do something here.\"); }}class B{ Runnable runnable; private void callHere() { runnable.run(); }} 可以看出Lamda表达式就是对函数式接口的一种省略的写法，上面的例子中，你可以用Lamda表达式写成一行，减小代码量，也可以不用Lamda表达式，写成6行，它们的运行结果都是一样的。 讲到这可能有的同学又有点蒙了，我Lamda表达式还没搞明白，又给我讲一堆函数式接口干嘛？别急，Lamda表达式的写法也有一定的规则，怎么写Lamda表达式跟这些函数式接口有紧密的关系，那么我们先说明下Consumer、Runnable、Callable这些接口是干什么用的呢？他们的区别是什么？ 不同函数式接口的区别就是参数的个数和有无返回值而已，你可以根据需要，选择使用哪个接口。 例如上述例子，我只是需要类B在某个时刻通知A执行一个操作，不需要返回值，也不带参数，那就用Runnable就行，意味着这段代码注重的是运行； 如果不要参数，但是需要返回值，就用Callable，其名字也意味这点； 相反如果需要一个参数，但是不需要返回值，就可以用Consumer，其名字也是一样，消费，给你一个参数，你拿去用就好，不用返回值给我； 同样的接口还有很多：BiFunction, Function0, Function1,…,Function22。Funtion22就是有22个参数和一个返回值（Function的意思就是即有参数又有返回值） 列几个函数式接口给大家感受下： 12345678910@FunctionalInterfacepublic interface Consumer&lt;T&gt; { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t);} 1234567891011@FunctionalInterfacepublic interface Function&lt;T, R&gt; { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t);} Lamda表达式的语法规则说完函数式接口，我们再回来说Lamda表达式的语法格式，Lamda表达式语法主要分为参数和表达式两部分： (parameters) -&gt;{ expression; } 其中，如果表达式只有一行，则可以省略花括号和分号；如果参数只有一个，也可以省略小括号，但是如果参数是空的，记住不能省略小括号。 例如上面的那几种函数式接口的写法就是： 1234567891011// 1. 没有餐素,也不返回任何值，类似于Runnable的接口的Lamda表达式形式：() -&gt; System.out.print(s) // 2. 不需要参数,但需要一个返回值, 类似于Callable的接口的Lamda表达式形式：() -&gt; 5 // 3. 接收一个参数(数字类型),有返回值，类似于Function的接口的Lamda表达式形式：x -&gt; 2 * x // 4. 接受2个参数(数字),有返回值，类似于BiFunction的接口的Lamda表达式形式：(int x, int y) -&gt; x + y 以上就是对Java中Lamda表达式的基本知识点的理解。 关于 @FunctionalInterface 注解Java 8为函数式接口引入了一个新注解@FunctionalInterface，主要用于编译级错误检查，加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。 正确例子，没有报错： 12345@FunctionalInterfaceinterface GreetingService{ void sayMessage(String message);} 错误例子，接口中包含了两个抽象方法，违反了函数式接口的定义，Eclipse 报错提示其不是函数式接口。 提醒：加不加 @FunctionalInterface 对于接口是不是函数式接口没有影响，该注解只是提醒编译器去检查该接口是否仅包含一个抽象方法 函数式接口里允许定义默认方法 函数式接口里是可以包含默认方法，因为默认方法不是抽象方法，其有一个默认实现，所以是符合函数式接口的定义的； 如下代码不会报错： 123456789101112131415@FunctionalInterfaceinterface GreetingService{ void sayMessage(String message); default void doSomeMoreWork1() { // Method body } default void doSomeMoreWork2() { // Method body }} 函数式接口里允许定义静态方法 函数式接口里是可以包含静态方法，因为静态方法不能是抽象方法，是一个已经实现了的方法，所以是符合函数式接口的定义的； 如下代码不会报错： 12345678@FunctionalInterfaceinterface GreetingService { void sayMessage(String message); static void printHello(){ System.out.println(\"Hello\"); }} 函数式接口里允许定义 java.lang.Object 里的 public 方法 函数式接口里是可以包含Object里的public方法，这些方法对于函数式接口来说，不被当成是抽象方法（虽然它们是抽象方法）；因为任何一个函数式接口的实现，默认都继承了 Object 类，包含了来自 java.lang.Object 里对这些抽象方法的实现； 如下代码不会报错： 12345678@FunctionalInterfaceinterface GreetingService { void sayMessage(String message); @Override boolean equals(Object obj);}","link":"/uncategorized/%E5%AF%B9lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"},{"title":"将ViewPager放在RecyclerView中的问题","text":"","link":"/uncategorized/%E5%B0%86viewpager%E6%94%BE%E5%9C%A8recyclerview%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"对使用ViewPager的一点理解","text":"大家都用过ViewPager吧😄，使用ViewPager时，需要给它配一个Adapter，通常我们要继承下面三个Adapter来，分别是： ———&gt;最基本的PagerAdapter ——————&gt;继承PagerAdapter的FragmentPagerAdapter ——————&gt;继承PagerAdapter的FragmentStatePagerAdapter 那么这三个Adapter有什么区别，我们应该怎么选择呢？ 1.关于PagerAdapter首先，我们知道如果继承了PagerAdapter，需要我们实现下面两个方法: 123456789101112131415161718192021/** * Return the number of views available. */public abstract int getCount();/** * Create the page for the given position. The adapter is responsible * for adding the view to the container given here, although it only * must ensure this is done by the time it returns from * {@link #finishUpdate(ViewGroup)}. * * @param container The containing View in which the page will be shown. * @param position The page position to be instantiated. * @return Returns an Object representing the new page. This does not * need to be a View, but can be some other container of the page. */public Object instantiateItem(ViewGroup container, int position) { return instantiateItem((View) container, position);} 第一个是要告诉ViewPager一共有几个页面，第二个则是ViewPager需要加载页面了，你需要根据position创建不同的页面对象，这里通常是View对象。 当然，如果你的ViewPager中内容比较复杂，需要用Fragment来自动管理其生命周期，那么可以使用FragmentPagerAdapter和FragmentStatePagerAdapter中的一种，那么他俩有什么区别呢？ 首先我们看一下FragmentPagerAdapter的instantiateItem和destroyItem方法： 12345678910111213141516171819202122232425262728293031323334353637383940 @Override public Object instantiateItem(ViewGroup container, int position) { ... final long itemId = getItemId(position); // Do we already have this fragment? String name = makeFragmentName(container.getId(), itemId); Fragment fragment = mFragmentManager.findFragmentByTag(name); if (fragment != null) { if (DEBUG) Log.v(TAG, \"Attaching item #\" + itemId + \": f=\" + fragment); mCurTransaction.attach(fragment); } else { fragment = getItem(position); if (DEBUG) Log.v(TAG, \"Adding item #\" + itemId + \": f=\" + fragment); mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); } ... return fragment; } @Override public void destroyItem(ViewGroup container, int position, Object object) { if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } if (DEBUG) Log.v(TAG, \"Detaching item #\" + getItemId(position) + \": f=\" + object + \" v=\" + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object); }public long getItemId(int position) { return position; } private static String makeFragmentName(int viewId, long id) { return \"android:switcher:\" + viewId + \":\" + id; } 可以看出instantiateItem方法在添加Fragment时，会带一个Fragment的名字，其实就是Tag： 1mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); 这个Tag是根据一定规则从makeFragmentName中获得的，这里唯一变化的就是id，默认的id可从getItemId(position)中看到，就是当前的position，保证了每个fragment的tag是唯一的。 当ViewPager通过instantiateItem获取Fragment的时候，会先根据之前设置的Tag找一下这个Fragment存不存在： 1mFragmentManager.findFragmentByTag(name) 根据获取到的Fragment有两种添加方式，如果根据Tag找到了之前存在的Fragment，就attach上去： 1mCurTransaction.attach(fragment); 如果没找到，那就把新创建的Fragment add上去: 1mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); 当不用这个Fragment的时，会调用destroyItem方法，可以看到这里是detach掉了Fragment，并没有销毁。 综上，一个页面只会创建一次，创建时根据当前的position给Fragment设置一个Tag，当不需要时只是把Fragmetn detach掉，并不会销毁，下次需要时通过Tag复用Fragment。 所以，如果你有大量的Fragment要展示，FragmentPagerAdapter会持有每一个Fragment不释放，最终走向OOM。 所以，无论使用PagerAdapter还是FragmentPagerAdapter，有多少页面，就会创建多少页面对象，页面很多的情况下，会非常占用内存，虽然这样，但是它们也有各自的应用场景，例如，App的首次安装的启动引导页面个数是固定的，而且如果比较复杂，通常做成Fragment，这时使用FragmentPagerAdapter较为合适；而如果页面中有需要自动轮播卡片的地方，则可以使用PagerAdapter实现，因为其页面一般都是View，结构简单，数量也是固定的。 那如果我需要做一个可以无限滑动的卡片，就需要用到FragmentStatePagerAdapter了，我们看一下FragmentStatePagerAdapter的instantiateItem和destroyItem方法： 1234567891011121314151617181920212223242526272829303132/** * Return the Fragment associated with a specified position. */public abstract Fragment getItem(int position);@Overridepublic Object instantiateItem(ViewGroup container, int position) { ... if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } Fragment fragment = getItem(position); while (mFragments.size() &lt;= position) { mFragments.add(null); } ... mCurTransaction.add(container.getId(), fragment); return fragment;}@Overridepublic void destroyItem(ViewGroup container, int position, Object object) { Fragment fragment = (Fragment) object; ... mCurTransaction.remove(fragment);} 可以看到，FragmentStatePagerAdapter在初始化页面时，通过getItem这个抽象方法来获得Fragment，并将其add到容器里，而不用的时候直接remove掉，这样就不会一直占用Fragment，可以实现无限滑动，唯一关心的就是在getItem中创建一个Fragment就可以了。 以上就是我对三种PagerAdapter的简单理解。在使用ViewPager的过程中，除了adapter的选择，还需要到了下面的问题。 2.常见的两个问题小析1.notifyDataSetChanged()后页面没有刷新的问题这个问题主要是由于当数据更新时，ViewPager会调用dataSetChanged方法： 123456789101112131415161718192021222324252627282930313233343536373839void dataSetChanged() { // This method only gets called if our observer is attached, so mAdapter is non-null. ... for (int i = 0; i &lt; mItems.size(); i++) { final ItemInfo ii = mItems.get(i); final int newPos = mAdapter.getItemPosition(ii.object); if (newPos == PagerAdapter.POSITION_UNCHANGED) { continue; } if (newPos == PagerAdapter.POSITION_NONE) { mItems.remove(i); i--; if (!isUpdating) { mAdapter.startUpdate(this); isUpdating = true; } mAdapter.destroyItem(this, ii.position, ii.object); needPopulate = true; if (mCurItem == ii.position) { // Keep the current item in the valid range newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1)); needPopulate = true; } continue; } ... } ...} 这个方法会调用adapter的getItemPosition()来获得object的位置情况是否发生变化，如果不发生变化就不更新了，如果而这个方法默认是返回的就是POSITION_UNCHANGED： 123456789101112131415161718 /** * Called when the host view is attempting to determine if an item's position * has changed. Returns {@link #POSITION_UNCHANGED} if the position of the given * item has not changed or {@link #POSITION_NONE} if the item is no longer present * in the adapter. * * &lt;p&gt;The default implementation assumes that items will never * change position and always returns {@link #POSITION_UNCHANGED}. * * @param object Object representing an item, previously returned by a call to * {@link #instantiateItem(View, int)}. * @return object's new position index from [0, {@link #getCount()}), * {@link #POSITION_UNCHANGED} if the object's position has not changed, * or {@link #POSITION_NONE} if the item is no longer present. */public int getItemPosition(Object object) { return POSITION_UNCHANGED;} 所以要想每次刷新都让页面更新，需要在adapter中重写getItemPosition方法，并返回POSITION_NONE就可以了： 12345@Overridepublic int getItemPosition(Object object) { return POSITION_NONE;} 2.初始化数据时不会调用OnPageChangeListener相信大家都遇到过这种情况，就是ViewPager初始化时并不会调用OnPageChangeListener，所以很多时候我们都是手动调用第一页的onPageSelected方法: 123456789101112131415161718192021222324 private ViewPager.OnPageChangeListener onPageChangeListener = new ViewPager.OnPageChangeListener() { @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { } @Override public void onPageSelected(int position) { } @Override public void onPageScrollStateChanged(int state) { } }; public void OnCreate(){ ... mViewPager.setOnPageChangeListener(onPageChangeListener);onPageChangeListener.onPageSelected(0); // 手动调用第一页 ... } 但是如果如果你使用的是FragmentPagerAdapter时，会发现在onPageSelected(0)时，会发现Fragment还没有创建成功，这时候会出现NPE(NullPointerException)。所以这时候可以这样写： 123456mViewPager.post(new Runnable(){@Override public void run() { onPageChangeListener.onPageSelected(0); // 手动调用第一页 }}); 这样就会在viewpager的UI事件队列完成后处理onPageSelected方法的内容，这个时候Fragment已经好了。 但是，虽然这样，讲要进行的工作交给post会打乱同步时序，让要做的事充满了不确定性，我不知道它什么时候能调用onPageSelected方法。而且这样做也存在另外一个问题，当使用notifyDataSetChanged()刷新数据时，还是不会调用当前页的onPageSelected来更新当前页面，所以我更倾向于下面这种方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyPagerAdapter extends FragmentStatePagerAdapter { ... private Object lastPrimaryItem; private OnPageSwitchListener onPageSwitchListener; public MyPagerAdapter(FragmentManager fm, OnPageSwitchListener onPageSwitchListener) { super(fm); this.onPageSwitchListener = onPageSwitchListener; } @Override public void setPrimaryItem(ViewGroup container, int position, Object object) { super.finishUpdate(container); super.setPrimaryItem(container, position, object); if (object == lastPrimaryItem) { return; // setPrimaryItem会多次调用，过滤掉多余的调用 } lastPrimaryItem = object; MyFragment fragment = (MyFragment)object; if (onPageSwitchListener != null &amp;&amp; fragment != null) { onPageSwitchListener.onPageSwitch(position, fragment); } } @Override public void finishUpdate(ViewGroup container) { // 这里将finishUpdate放到setPrimaryItem之前执行，见上面的方法👆 // 原因是finishUpdate后的Fragment才算正式可以用了 } public interface OnPageSwitchListener{ void onPageSwitch(int position, MyFragment fragment); }}class MyActivity extends Activity implements MyPagerAdapter.OnPageSwitchListener{ @Override public void onPageSwitch(int position, MyFragment fragment) { // Do whatever you like here. :) }} 简单说就是，PagerAdapter中有一个重要的方法叫setPrimaryItem，当一个页面显示的时候都会调用这个方法（多次），通过一些简单的处理，可以实现与mViewPager.setOnPageChangeListener()类似的功能，这样就不用每次调用onPageChangeListener.onPageSelected(0)或者使用Post操作了。 以上分析较为肤浅，有问题欢迎指正、补充，谢谢🙏 参考 [1] https://stackoverflow.com/questions/16074058/onpageselected-doesnt-work-for-first-page [2] https://stackoverflow.com/questions/11794269/onpageselected-isnt-triggered-when-calling-setcurrentitem0","link":"/uncategorized/%E5%AF%B9%E4%BD%BF%E7%94%A8viewpager%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"},{"title":"摆动排序-归并排序-归并排序","text":"排序- 摆动排序给你一个没有排序的数组，请将原数组就地重新排列满足如下性质: nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3].... 答案： 123456789101112131415161718192021222324public class Solution { /** * @param nums a list of integer * @return void */ public void wiggleSort(int[] nums) { for(int i=1; i&lt;nums.length; i++){ if ((i%2==1 &amp;&amp; nums[i-1]&gt;nums[i])|| (i%2==0 &amp;&amp; nums[i-1]&lt;nums[i])) swap(nums, i-1, i); } } /** * Swap two values * */ public void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; }} -归并排序原理： 给一组整数，按照升序排序。样例: 给出 [3, 2, 1, 4, 5], 排序后的结果为 [1, 2, 3, 4, 5]。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * Created by kevin on 17-8-21. */public class MergeSort { /** * Constructive function * @param target */ MergeSort(int target[]){ internalMergeSort(target, 0, target.length-1); for (int value : target) { System.out.println(value); } } /** * Split the dataset and iterator * @param target the target array * @param left left pointer * @param right right pointer */ void internalMergeSort(int target[], int left, int right){ if (left &lt; right){ int middle = (left + right)/2; System.out.println(left+\"-\"+middle+\"-\"+right); try { internalMergeSort(target, left, middle); internalMergeSort(target, middle+1, right); }catch (StackOverflowError e){ } merge(target, left, middle, right); } } /** * Merge sets * @param target the target array * @param left left pointer * @param middle the middle * @param right right pointer */ void merge(int target[], int left, int middle, int right){ int l =left; int m = middle+1; // Notice the m need to start from middle+1 int result[] = new int[right-left+1]; int k = 0; while(l&lt;=middle &amp;&amp; m &lt;= right){ if (target[l]&gt;target[m]) result[k++] = target[m++]; else result[k++]= target[l++]; } while(l&lt;=middle){ result[k++] = target[l++]; } while (m &lt;= right){ result[k++] = target[m++]; } for (int i=left; i&lt;=right;i++){ // Notice the i need be iterated from left to right target[i] = result[i-left]; } } /** * main * @param args */ public static void main (String args[]){ int target[] = { 51, 46, 20, 18, 65, 97, 82, 30, 77, 50 }; for (int value : target) { System.out.println(value); } new MergeSort(target); }} -快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Created by kevin on 17-8-22. */public class QuickSort { public QuickSort(int[] targetArr) { recursionMethod(targetArr, 0, targetArr.length - 1); for (int r : targetArr) { System.out.println(r); } } void recursionMethod(int[] partArr, int start, int end) { if (start &gt;= end) return; int pivot = (start + end) / 2; int pivotValue = partArr[pivot]; int lefP = start; int rigP = end; // left pointer move to right, and right pointer move to left. // left pointer stopped moving when encounter a number larger than or equal with pivot. // right pointer stopped moving when encounter a number smaller than pivot. while (lefP &lt;= rigP) { // moving left pointer while (lefP &lt;= rigP &amp;&amp; partArr[lefP] &lt; pivotValue) lefP++; while (lefP &lt;= rigP &amp;&amp; partArr[rigP] &gt; pivotValue) rigP--; // Now, lefP point at a bigger value, and rigP point at a littler value. if (lefP &lt;= rigP) { // Then swap these two values. swapValues(partArr, lefP, rigP); // move pointer lefP++; rigP--; } } recursionMethod(partArr, start, rigP); recursionMethod(partArr, lefP, end); } void swapValues(int[] partArr, int left, int right) { // swap the left larger value and the right smaller value. int temp = partArr[left]; partArr[left] = partArr[right]; partArr[right] = temp; } public static void main(String args[]) { int target[] = {51, 46, 20, 18, 65, 97, 82, 30, 77, 50, 4, 6, 77, 8, 32, 2, 1, 754, 7347, 2352, 656, 75467, 2534, 6436, 2342, 73, 25, 253, 654, 2542, 34252, 6453, 345, 736, 5623, 2345234, 25, 34534, 456, 7456, 776, 567, 4564, 34, 345, 456, 345, 2, 745, 453, 7643625, 25}; try { new QuickSort(target); } catch (StackOverflowError e) { } }}","link":"/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"小麦抽样管理系统说明书","text":"注册与登录软件打开后，点击 注册 按钮注册账号，在注册界面，详细的填写个人信息和个人银行卡信息，用于接收补助， 用户名 和 密码 作为需要仔细记住用于日后登录。如果注册完成后发现内容填写有误，后期可在主界面的【设置】-&gt;【个人资料】中修改。注册界面如图1所示。 图1 注册界面示意图 用户凭借 “用户名” 和 “密码” 登录系统，在登录界面填写“用户名” 和 “密码” 后点击 登录 按钮即可登录。登录界面如图1所示： 图2 登录界面 主界面介绍登录成功后，进入系统主界面，底部有三个标签【任务】、【完成】和【设置】，分别代表： 【任务】：当前正在进行的抽样任务列表，进行抽样单填写，上传，补采等操作。任务名下的不同颜色后的数字分别表示 未完成， 已完成， 已上传， 审核通过， 审核未通过 和 补采 的抽样单的数量。点击任务名称，展开的列表中第一个是 抽样单模板 ，通过填写抽样单模板，生成多个抽样单。 【完成】：已经完成的抽样任务列表。点击任务名称查看已经完成的历史任务。 【设置】：设置中可以查看并修改个人信息；使用采样工具箱（地图导航、记事便签和指南针）；执行注销操作。主界面如图3所示。 图3 主界面图片 抽样单界面抽样单内容 填写部分：直接通过输入法输入内容。 地址部分：抽样地址通过手机定位自动填写，如下图所示，更详细的地址信息可以在下方文本框进行补充。 经纬度部分：通过定位自动填写经纬度信息，不可修改。 拍照和录像部分：通过点击 拍摄照片 和 拍摄视频 按钮进行拍照和录像操作 选择部分：直接点击来选择相应选项 日期选择部分：通过滑动选择日期 在填写抽样单的过程中，可以点击顶部的 打印 按钮打印可黏贴的标签。当前的样品信息填写完成后，可以点击顶部的 加样 图标直接继续填写下一个样品的信息，所有样品信息填写完成后，点击右上角的 保存 按钮进行保存。顶部按钮如图4所示。 图4 抽样单操作按钮 抽样单列表所有的样品信息填写完成后，可以在主界面的 任务 标签查看已填写的抽样单列表，如图5所示。点击抽样单右侧的 菜单按钮（三个点） 可展开菜单，对抽样单进行 编辑，删除，上传，补采 操作。","link":"/%E6%97%A5%E5%B8%B8%E6%B1%87%E6%8A%A5/%E5%B0%8F%E9%BA%A6%E6%8A%BD%E6%A0%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E%E4%B9%A6/"},{"title":"原来我根本不会用Android Studio","text":"背景最近在工作中解锁了一些使用Android Studio的技巧，在这里记录一下。 1. 为什么明明我的电脑剩余那么多内存，用Android Studio打开多个工程后就开始卡顿了呢？有一次在使用Android stuido的时候发现会卡顿无比，滚动鼠标都卡，但我的机器明明配置很高，系统剩余的内存也很多啊。 于是，打开内存指示器，查看Android Studio的内存使用情况： 打开设置 -&gt; Appearance -&gt; Window Options -&gt; Show memory indicator 勾选了Show memory indicator 之后，就可以在Android Studio的右下角看到内存指示器了： 双击指示器可以手动进行GC操作。这里显示的就是Android Studio占用的内存大小（左）和分配给Android Studio使用的最大内存（右）。如果发现占用内存基本上快要等于分配的最大内存的时候，说明需要分配更多的内存给Android Studio了。当时我的机器显示的是1020/1024M，这应该就是其默认分配的内存大小，基本上分配的内存已经快要用完了，这也就是为啥明明电脑内存剩余很多，但是Android Studio却很卡顿的原因。 于是，通过下面步骤来提高分配给Android的内存： 打开菜单Help-&gt;Edit Custom VM Options，这时，会在新窗口打开一个studo.vmoptions文件（如果之前没有，会新创建一个），在打开的文件中输入下面代码配置虚拟机堆栈的最大分配内存： 1-Xmx4096m 这里可以根据自己机器的内存大小，对Android Studio进行配置，配置完成后，重启Android Studio，看到右下角的内存指示器显示的最大分配内存已经发生了变化，就说明生效了。 2. 提高生产效率的快捷键无意中，在Android Studi的Help菜单中发现了一个叫Productivity Guide的窗口，里面列出的一些快捷键都是跟效率有关的： 例如有我们常用的自动补全（Basic code completion），还有Complete Statement这种神奇的功能，再也不用移动箭头和手动加分号了！！点击功能名字下方会列出快捷键和说明，建议把这里面的功能过一遍，相信会很有帮助。 列几个我用的非常上瘾的在下面： Quick Definition Lookup: 将定义以弹窗的形式打开，而不跳转到定义处，快捷键：Ctrl+Shift+I Extract Method/Function: 将一段代码抽出成一个函数，快捷键： Ctrl+Alt+M Generate菜单：Alt+Insert Introduce Constant：使某个量变成常量Ctrl+Alt+C 继承方法 Ctrl + O 实现方法 Ctrl + I 查看参数信息 Ctrl + P Surround With Ctrl+Alt+T Extend select Ctrl+W 当前行/函数/块上下移动 Shift+Meta+Up/Down 3. 调试的技巧首先，日常调试中最常用的调试方法就是打断点和加Log了，AdroidStudro中的断点功能非常强大，在断点上点右键，在弹出的窗口中点More或者直接点击Debug标签中的断点列表可以对断点进行更有用的设置，下面来详细说下这个断点设置页面： Suspend + Evaluate and log：调试的时候需要在某处添加一个Log，这时候如果用Log.e(xx,xxx)加入需要重新编译并安装到手机上才能查看。我们可以取消勾选Suspend，这样程序运行到断点处并不会停下，在Evaluate and log中写好想打印的log，运行到断点处在Console中就会打出Log信息了。 Evaluate and log：这个功能与Evaluate功能相同，可以在调试时，对一个实例进行操作，例如读取某个对象的值，修改某个对象的值等。这里的Evaluate and log的区别就是会将操作的结果打印到Console。 使用Condition给断点添加条件。在Condition中输入一个返回值为Bollean的语句，那么只有返回true的时候，断点才会生效。 通过上面的工具可以更方便的了解程序的运行状态。当然，这还是避免不了我们有时会设置了错误的断点位置，导致： 这时，我们可以利用调用栈，从下往上的查看调用顺序，调试时，调用栈会在Debug标签中的Debugger-&gt;Frames中显示： 在上面的调用栈中，背景底色是黄色的表示是来自SDK的调用，背景是正常的Android的主题色表示的是来自你代码的调用。 调用栈非常有用，举个例子：有一次在调试时，点击了界面上一个按钮后Activity就关掉了，但是代码中却无论怎么找都找不到对这个按钮的监听，没有setOnClickListener，那点击后是怎么执行的呢？就在我愁眉不展的时候，老司机出现了，告诉我既然肯定会被Activity被Finish掉了，那在Finish函数里加断点，查看调用栈就可以顺藤摸瓜的找到按钮的点击事件处理代码。果然就找到了，原来按钮的监听定义在了Base类中。 4. 定位当前页面的源码位置阅读新项目代码时，领导让我修改页面上一个控件，这时首先要做的就是代码中找到这个页面，于是，菜鸟的我我就开始从MainActivity开始顺着代码往下捋着找，发现要找到一个控件要找半天，有时候甚至半天都找不到。于是，我总结了两条寻找Activity或者某个View的方法： 在Androd Studio中点击Tools-&gt;Layout Inspector，选择当前进程后就会弹出当前任务栈中所有的Activity的列表，这时候在源码中搜索（Ctrl+Shift+F）名字就可以Activity的源码位置。如果需要找页面上某一个控件View，可以继续点击Activity，在打开的节面中选中要寻找的控件，查看其id，再根据id搜索就可以找到View了。但是这个方法并不总是那么好用，有时任务栈中只有一个Activity时，就不会出现Activity列表，直接打开布局的Capture文件了。 另一种方法跟Android Studio无关，是通过Android系统自带的dumpsys命令获取任务栈及Activity信息，在命令行中输入下面语句: 1adb shell dumpsys activity activities | grep -A 20 \"A=com.xxxx.xxxx\" 这样就能得到当前的Activity信息了： 把这条命设置别名，放到bashrc文件中，就可以在在命令行里直接使用了： 123# 放到bashrc文件中export package_name=\"A=xxx.xxx.xxx\" # 写好包名alias whatisthispage=\"adb shell dumpsys activity activities | grep -A 20 \" 运行时，直接运行whatisthispage $package_name就可以了。","link":"/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/%E5%8E%9F%E6%9D%A5%E6%88%91%E6%A0%B9%E6%9C%AC%E4%B8%8D%E4%BC%9A%E7%94%A8android-studio/"},{"title":"数据结构之二叉树相关","text":"二叉树的相关术语:树的结点:包含一个数据元素及若干指向子树的分支； 孩子结点:结点的子树的根称为该结点的孩子； 双亲结点:B 结点是A 结点的孩子，则A结点是B 结点的双亲； 兄弟结点:同一双亲的孩子结点； 堂兄结点:同一层上结点； 祖先结点: 从根到该结点的所经分支上的所有结点子孙结点:以某结点为根的子树中任一结点都称为该结点的子孙 结点层:根结点的层定义为1；根的孩子为第二层结点，依此类推； 树的深度:树中最大的结点层 结点的度:结点子树的个数 树的度: 树中最大的结点度。 叶子结点:也叫终端结点，是度为 0 的结点； 分枝结点:度不为0的结点； 有序树:子树有序的树，如:家族树； 无序树:不考虑子树的顺序； 参考 二叉树相关知识点: 在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。 二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决。 二叉树相关面试题目:参考网上的相关面试题，添加了自己的理解（括号部分），并将代码改为java实现。 注意，在递归过程中，若一共有n种情况，要有m(m&lt;n)种情况用于控制递归停止，n-m个条件用于递归。 首先，二叉树的Java定义如下: 123456789101112131415/*** 二叉树定义**/public class BinaryTree{ int rootNode = null; // 根节点 BinaryTree leftNode = null; // 左子节点 BinaryTree rightNode = null; // 右子节点 public BinaryTree (int rootNode, BinaryTree leftNode, BinaryTree rightNode){ // 构造函数 this.rootNode=rootNode this.leftNode=leftNode this.rightNode=rightNode }} 求二叉树中的节点个数 递归解法: 如果二叉树为空，节点个数为0 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1 参考代码如下: 12345678public long getNodeNum(BinaryTree bt){ // 如果二叉树为空，节点个数为0 if(bt.rootNode == null) return 0; // 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1 return getNodeNum(bt.leftNode) + getNodeNum(bt.rightNode) + 1;} 求二叉树的深度 递归解法: 如果二叉树为空，二叉树的深度为0 如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1 参考代码如下:12345678910public long getBTDeep(BinaryTree bt){ // 如果二叉树为空，二叉树的深度为0 if(bt.rootNode == null) return 0; // 如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1 long leftDeep = getBTDeep(bt.leftDeep); long rightDeep = getBTDeep(bt.rightDeep); return leftDeep&gt;rightDeep ? (leftDeep + 1) : (rightDeep + 1);} 前序、中序和后序遍历 前序遍历递归解法: 如果二叉树为空，空操作 如果二叉树不为空，访问根节点，再前序遍历左子树，再前序遍历右子树 参考代码如下:1234567public void preOrderTraverse(BinaryTree bt){ if (bt.rootNode == null) return; doSomeThing(bt.rootNode); preOrderTraverse(bt.leftNode); preOrderTraverse(bt.rightNode);} 中序和后序雷同。 分层遍历二叉树（按层次从上往下，从左往右） 相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作:弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。 参考代码如下: 1234567891011121314public void levelTraverse(BinaryTree bt){ if(bt.rootNode == null) return; LinkedList&lt;BinaryTree&gt; queue = new LinkedList&lt;BinaryTree&gt;(); // LinkedList实现了Java的Queen接口 queue.addLast(bt); while (!queue.isEmpty()){ popBT = queue.pollFirst(); if (bt.leftNode != null) queue.addLast(bt.leftNode); if (bt.rightNode != null) queue.addLast(bt.rightNode); } return;} 将二叉查找树变为有序的双向链表 要求不能创建新节点，只调整指针。 递归解法: （1）如果二叉树查找树为空，不需要转换，对应双向链表的第一个节点是NULL，最后一个节点是NULL （2）如果二叉查找树不为空: 如果左子树为空，对应双向有序链表的第一个节点是根节点，左边不需要其他操作； 如果左子树不为空，转换左子树，二叉查找树对应双向有序链表的第一个节点就是左子树转换后双向有序链表的第一个节点，同时将根节点和左子树转换后的双向有序链 表的最后一个节点连接； 如果右子树为空，对应双向有序链表的最后一个节点是根节点，右边不需要其他操作； 如果右子树不为空，对应双向有序链表的最后一个节点就是右子树转换后双向有序链表的最后一个节点，同时将根节点和右子树转换后的双向有序链表的第一个节点连接。 参考代码如下: 1234567891011121314151617181920212223242526TODOpublic class Solution { private TreeNode head=null; private TreeNode tail=null; public TreeNode Convert(TreeNode pRootOfTree) { visit(pRootOfTree); return head; } public void visit(TreeNode root) { if (root == null) { return; } visit(root.left); createList(root); visit(root.right); } public void createList(TreeNode cur){ cur.left=tail;//把当前的节点接到链表的尾部 if(tail!=null){//双向连接 tail.right=cur; }else{ head=cur; } tail=cur;//更新尾结点为当前结点，或者说:尾结点后移 } } 求二叉树第K层的节点个数 递归解法: 如果二叉树为空或者k&lt;1返回0 (不是k层，或节点不存在，不计数) 如果二叉树不为空并且k==1，返回1 （第k层，计数+1） 如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 （递归寻找第k层） 参考代码如下:123456789101112131415public int getNodeNumOfKthLevel(BinaryTree bt, int k){ // 如果二叉树为空或者k&lt;1返回0 if (bt.rootNode == null || k&lt;1) return 0; // 如果二叉树不为空并且k==1，返回1 if (k == 1) return 1; // 如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 // 解释:通过控制k来控制递归，即每一层K都减一，最后到达k-1层时k减为1，停止递归。 int leftNum = getNodeNumOfKthLevel(bt.leftNode, k-1); int rightNum = getNodeNumOfKthLevel(bt.rightNode, k-1); return leftNum + rightNum; // 返回左右孩子节点下的节点个数} 求二叉树中叶子节点的个数 递归解法: 如果二叉树为空，返回0 （节点不存在） 如果二叉树不为空且左右子树为空，返回1 （节点为叶子节点，计数+1） 如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 （节点不是叶子节点，递归寻找叶子节点） 参考代码如下:1234567891011121314public int getLeafNodeNum(BinaryTree bt){ // 如果二叉树为空，返回0 if (bt.rootNode == null) return 0; // 如果二叉树不为空且左右子树为空，返回1 if (bt.rootNode != null &amp;&amp; bt.leftNode == null &amp;&amp; bt.rightNode == null) return 1; // 如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 int leftNum = getLeafNodeNum(bt.leftNode); int rightNum = getLeafNodeNum(bt.rightNode); return leftNum + rightNum;} 判断两棵二叉树是否结构相同 不考虑数据内容。结构相同意味着对应的左子树和对应的右子树都结构相同。 递归解法: 如果两棵二叉树都为空，返回真 (判断根节点) 如果两棵二叉树一棵为空，另一棵不为空，返回假 (判断根节点) 如果两棵二叉树都不为空，如果对应的左子树和右子树都同构返回真，其他返回假 (递归判断孩子节点) 参考代码如下:12345678910111213public boolean structureCmp(BinaryTree bt1, BinaryTree bt2){ // 如果两棵二叉树都为空，返回真 if (bt1.rootNode == null &amp;&amp; bt2.rootNode == null) return true; // 如果两棵二叉树一棵为空，另一棵不为空，返回假 if (bt1.rootNode == null || bt2.rootNode == null) return false; // 如果两棵二叉树都不为空，如果对应的左子树和右子树都同构返回真，其他返回假 boolean leftCmp = structureCmp(bt1.leftNode, bt2.leftNode); boolean rightCmp = structureCmp(bt1.rightNode, bt2.rightNode); return leftCmp &amp;&amp; rightCmp; 扩展 判断两棵二叉树是否相同（结构+数值） 对上述问题（8）的扩展，考虑数据内容。 递归解法: 如果两棵二叉树都为空，返回真 (判断根节点结构) 如果两棵二叉树一棵为空，另一棵不为空，返回假 (判断根节点结构) 如果两棵二叉树都不为空，判断值不相等，返回假 (判断根节点值) 如果两棵二叉树都不为空，判断值相等，判断对应的左子树和右子树都返回真则返回真，其他返回假 (递归判断孩子节点的结构和值) 参考代码如下:1234567891011121314151617public boolean structureCmp(BinaryTree bt1, BinaryTree bt2){ // 如果两棵二叉树都为空，返回真 if (bt1.rootNode == null &amp;&amp; bt2.rootNode == null) return true; // 如果两棵二叉树一棵为空，另一棵不为空，返回假 if (bt1.rootNode == null || bt2.rootNode == null) return false; // 如果两棵二叉树都不为空，判断值不相等，返回假 (判断根节点值) if (bt1.rootNode != bt2.rootNode) return false; // 如果两棵二叉树都不为空，判断值相等，判断对应的左子树和右子树都返回真则返回真，其他返回假 (递归判断孩子节点的结构和值) boolean leftCmp = structureCmp(bt1.leftNode, bt2.leftNode); boolean rightCmp = structureCmp(bt1.rightNode, bt2.rightNode); return leftCmp &amp;&amp; rightCmp; 判断二叉树是不是平衡二叉树 平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 递归解法： 如果二叉树为空，返回真 如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假 12345678910111213141516171819public final int UNB = -1; // 定义一个不可能的树的高度作为不平衡的代表public boolean isBalanced(BinaryTree bt) { int result = balanceJudge(bt); // 判断数的高度，如果为-1，则数不平衡，否则树是平衡的。 if(result != UNB)return true; else return false;}/*** 判断是否平衡，返回的为当前树的高度**/private int balanceJudge(BinaryTree bt){ if(bt.rootNode==null) return 0; int l = balanceJudge(bt.leftNode); int r = balanceJudge(bt.rightNode); if(l==UNB || r== UNB || Math.abs(l-r)&gt;1) return UNB; // 如果左树或右树有任何一个不平衡，或者高度相差超过1，则整个二叉树不平衡 return 1+(l&gt;r?l:r); // 平衡，返回深度，深度为左右子树中最深的树的深度} 求二叉树的镜像 递归解法： 如果二叉树为空，返回空 如果二叉树不为空，求左子树和右子树的镜像，然后交换左子树和右子树 12345678910public BinaryTree mirrorBT(BinaryTree bt){ if(bt.rootNode==null) return null; BinaryTree leftTree = mirrorBT(bt.leftNode); BinaryTree rightTree = mirrorBT(bt.rightNode); // 交换左右子树 bt.leftNode = rightTree; bt.rightNode = leftTree; return bt;}","link":"/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/"},{"title":"新抽样单协议","text":"1. 抽样单协议为了实现抽样系统中电子抽样单的灵活性，修改原抽样系统中的问题，修改抽样单协议如下。（协议括号中的英文为服务器与手机端传输时定义的Key，未经允许，不可修改。） 1.1 抽样单结构0抽样单仿照纸质抽样单，但比纸质抽样单功能更加丰富，抽样单的结构如下： 1234--单元格(cell)--单元格(cell)...--单元格(cell) 以上是一张抽样单，由多个单元格组成，没有其他任何杂项。 如果需要添加功能，需要在单元格类型属性中添加类型。 用户通过在线设计不同功能的单元格实现不同功能的抽样单。 1.2 单元格属性为了实现单元格的多样性，单元格具有多个属性，这些属性在使用在线设计抽样单功能时可以进行修改，下发到手机后，单元格的属性不可修改，手机根据不同的单元格类型(单元格属性之一) 属性，解析成不同的单元格。 下面介绍单元格的属性： 单元格名称(cell_name): 在制表时由用户填写，例如，“样品名称”，“亩产量”等 单元格类型(cell_type): 在制表时由用户选择，例如，文本类，填写类，照相类等。 单元格值(cell_value): 在制表时由用户填写，此属性仅对部分类型单元格有效，如填写类和选择类，其他单元格不受此属性影响。 单元格是否可编辑(cell_editable): 以下全为二值型属性(T,F,分别代表True，False)，在制表时选择。此属性仅对部分类型单元格有效，如填写类，其他单元格不受此属性影响。 单元格是否为必填(cell_fill_required): 同上，手机端的必填项单元格如果不填写不能保存 单元格是否可打印(cell_printable): 同上，代表单元格是否具有打印功能 单元格是否默认勾选打印(cell_default_print): 同上，代表单元格打印的默认勾选状态 单元格可否被加样(cell_copyable): 同上。关于加样功能，解释如下：假设以下场景，在同一个村采100个样品，抽样单中的“抽样所在村”单元格每次都要填写相同的村名，而其他的单元格“样品编号等” 则每次填写不同的内容，所以为了方便采样人员在填写抽样单模板时不必每次填写重复内容，本系统设计了加样功能，即填写抽样单时，在不退出当前模板的界面，点击“加样”按钮后，可被加样的单元格（需要改变内容的单元格）被复制，而不可被加样的单元格（不需要改变内容的单元格）不被复制，最后采样人员在一个模板界面可一键保存成多个抽样单。单元格的可否被加样属性需要抽样单设计者在制作抽样单时设计好。 除了以上的属性，开发者可以通过添加单元格类型来增加抽样单功能。但是，开发者在开发网页端和手机端时一定要谨慎:要将不同属性的单元格封装好，日后如果需要添加单元格属性，只需要对新的单元格类型进行封装即可进行二次开发。 可以看出，抽样单是由多个单元格组成，每个单元格具有多个属性，其中单元格的功能体现在单元格类型上，这好比一个公司（抽样单）又许多员工（单元格）组成，每个员工具有多个不同的属性（性别，姓名，工种等），而员工的功能体现在工种（单元格类型）上。 1.3 单元格类型为了增加抽样单的功能，目前的单元格类型有以下（按常用程度排序）： 抽样序列号单元格(type_serial_number): 用户标识抽样单的唯一编号，同时用于将抽样单和样品关联。格式如“W170001”，是最为常用的类型，是否可编辑为否，可否被加样为是，是否为必填为是 填写单元格(type_edit_text): 用于手机端填写信息，所有单元格属性对其生效。 显示单元格(type_text): 仅用于显示信息，单元格是否可编辑属性、单元格是否为必填属性对其无效 单选单元格(type_radio): 用于进行单项选择，如单元格名称为“自然灾害情况”，单元格值为“洪灾,涝灾”。单元格是否可编辑属性对其无效 多选单元格(type_multi_select): 用于进行多项选择，如单元格名称为“喷洒农药名称”，可能喷洒多种农药，单元格值为“A药,B药”。单元格是否可编辑属性对其无效 二级多选单选单元格(type_multi_then_single_choice): 一级为多选，二级也为单选。用于对单选的内容进行补充，如上述自然灾害情况，单元格值为“洪灾,涝灾;轻微,一般,严重”，即可在选择完灾害后，选择严重程度。单元格是否可编辑属性对其无效 地理位置坐标单元格(type_geographic_coordinates): 显示采样人员所在的经纬度。单元格值、单元格是否可编辑属性对其无效 地址单元格(type_address): 用于显示采样人员所在的地址信息，如“XX市，XX区，XX县”。 拍照单元格(type_photos): 用于采集照片。单元格值、单元格是否可打印、单元格是否默认勾选打印属性对其无效 录像单元格(type_vedios): 用于拍摄视频。单元格值、单元格是否可打印、单元格是否默认勾选打印属性对其无效 自动记录日期单元格(type_auto_record_date): 用于自动记录日期，如”XXXX年XX月XX日”。单元格值、单元格是否可编辑属性对其无效 自动记录时间单元格(type_auto_record_time): 用于自动记录时间，如“XX时XX分”。单元格、单元格是否可编辑属性对其无效 日期选择单元格(type_date_select): 用于用于手动选择日期。单元格值、单元格是否可编辑属性对其无效 签名单元格(type_sign) 用于签名。单元格值、单元格是否可编辑、单元格是否可打印、单元格是否默认勾选打印属性对其无效 2. Json实例下面的Json为使用该协议时，服务器与手机端传送的抽样单数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164{ \"specimen_sheet\": [ { \"cell_name\": \"样品编号\", \"cell_type\": \"type_serial_number\", \"cell_value\": \" \", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"抽样地点\", \"cell_type\": \"type_address\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"抽样地点经纬度\", \"cell_type\": \"type_geographic_coordinates\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"品种名称\", \"cell_type\": \"type_edit_text\", \"cell_value\": \" \", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"样品照片\", \"cell_type\": \"type_photos\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"采样视频\", \"cell_type\": \"type_vedios\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"F\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"该品种种植面积(亩)\", \"cell_type\": \"type_edit_text\", \"cell_value\": \" \", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"地力级别\", \"cell_type\": \"type_radio\", \"cell_value\": \"1级地,2级地,3级地\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"预估亩产水平(每亩)\", \"cell_type\": \"type_radio\", \"cell_value\": \"200-250,250-300,300-350,350-400,400-450,450-500,500以上\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"播种日期\", \"cell_type\": \"type_date_select\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"取样时间\", \"cell_type\": \"type_auto_record_date\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"施用农药情况\", \"cell_type\": \"type_edit_text\", \"cell_value\": \" \", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"主要气象灾害\", \"cell_type\": \"type_multi_then_single_choice\", \"cell_value\": \"干旱,洪涝,高温,低温;严重,一般,轻微\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"主要病虫害发生情况\", \"cell_type\": \"type_multi_then_single_choice\", \"cell_value\": \"条锈病,赤霉病,白粉病,纹枯病,蚜虫,麦蜘蛛,吸浆虫;严重,一般,轻微\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"病虫害情况照片\", \"cell_type\": \"type_photos\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"F\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"采样人签名\", \"cell_type\": \"type_sign\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"F\" } ]} 以上Json已经通过校验。 抽样单填写完成后，服务器收到的内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164{ \"specimen_sheet\": [ { \"cell_name\": \"样品编号\", \"cell_type\": \"type_serial_number\", \"cell_value\": \"W170103\", \"cell_editable\": \"F\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"抽样地点\", \"cell_type\": \"type_address\", \"cell_value\": \"黑龙江省哈尔滨市南岗区汇文广场\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"抽样地点经纬度\", \"cell_type\": \"type_geographic_coordinates\", \"cell_value\": \"经度:126.628284\\n纬度:45.715476\\n定位类型：网络定位\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"品种名称\", \"cell_type\": \"type_edit_text\", \"cell_value\": \" 1\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"样品照片\", \"cell_type\": \"type_photos\", \"cell_value\": \"CAMERA_868030021837446170514165338.jpg\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"采样视频\", \"cell_type\": \"type_vedios\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"F\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"该品种种植面积(亩)\", \"cell_type\": \"type_edit_text\", \"cell_value\": \" 38\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"地力级别\", \"cell_type\": \"type_radio\", \"cell_value\": \"3级地\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"预估亩产水平(每亩)\", \"cell_type\": \"type_radio\", \"cell_value\": \"300-350\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"播种日期\", \"cell_type\": \"type_date_select\", \"cell_value\": \"2017-05-14\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"取样时间\", \"cell_type\": \"type_auto_record_date\", \"cell_value\": \"2017-05-14\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"施用农药情况\", \"cell_type\": \"type_edit_text\", \"cell_value\": \" 38\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"主要气象灾害\", \"cell_type\": \"type_multi_then_single_choice\", \"cell_value\": \"高温,一般;\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"主要病虫害发生情况\", \"cell_type\": \"type_multi_then_single_choice\", \"cell_value\": \"赤霉病,一般;\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"T\", \"cell_default_print\": \"T\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"病虫害情况照片\", \"cell_type\": \"type_photos\", \"cell_value\": \"\", \"cell_editable\": \"T\", \"cell_fill_required\": \"F\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"T\" }, { \"cell_name\": \"采样人签名\", \"cell_type\": \"type_sign\", \"cell_value\": \"SIGN_868030021837446170514165225.jpg\", \"cell_editable\": \"T\", \"cell_fill_required\": \"T\", \"cell_printable\": \"F\", \"cell_default_print\": \"F\", \"cell_copyable\": \"F\" } ]}","link":"/%E6%97%A5%E5%B8%B8%E6%B1%87%E6%8A%A5/%E6%96%B0%E6%8A%BD%E6%A0%B7%E5%8D%95%E5%8D%8F%E8%AE%AE/"},{"title":"新采样系统设计","text":"抽样监督管理系统，致力于提高我国农业现代化建设水平，具有以下优势： 国家可以迅速的发现问题，根据质检结果制定相应的应急措施。 缩短抽样任务下发和上传的时间周期。 保证抽样过程的严谨性，提高抽样的质量和效率。 节省人力、物力，提高抽样检测的溯源能力。 抽样监督管理系统分为多级，上级可查看属于自己管理下级的抽样和质检信息，其中： 第一级 是国家级（农业部），该级别具有以下功能： 下发抽样任务： 根据国家法律法规，下发抽样任务到指定的省、市、自治区的承接机构。 查看抽样结果： 动态的查看全国各地的抽样情况和质检结果。 抽查任务完成情况： 抽查抽样过程是否合格。 第二级用户为各地的质检机构，该级别具有以下功能： 接收抽样任务： 接收由国家下发的抽样任务。 下发抽样任务： 将抽样任务下发到管辖区域的农民账号中。 审核农民抽样过程： 农民上传的采样资料进行审核，查看其采样位置是否正确，通过视频等信息确认其采样过程的完整性和正确性，保证采样的质量。 填写质量检测结果： 将农民采集的样品进行检测，并填写到抽样单中。 上传抽样任务： 上传样品数据到国家。 第三级 用户为 农民 或 农场主 ，该级别具有以下功能： 标记土地： 标记自己土地的地理位置。 采集样品： 系统根据其标记的地理位置随机生成采样区域。农民负责到要求的采样区域进行采样，并将样品放到上级下发的采样袋中进行封装，在采样和封装的过程中，全程记录其位置，并录像记录，封装带一旦封死，不可正常拆开。 邮寄样品： 农民或农场主将采集到的样品邮寄到上级质检机构。 企业级 用户，该级别不隶属于以上任何一级，企业用户可以通过该系统实现： 查看周边地区的粮食产量和品质信息。 查看周边粮仓的相关信息。 查询相关的农场主信息。","link":"/%E6%97%A5%E5%B8%B8%E6%B1%87%E6%8A%A5/%E6%96%B0%E9%87%87%E6%A0%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"title":"正则表达式上手","text":"正则表达式是计算机世界里的基础技能，很多东西都是建立在正则表达式之上。学会使用正则表达式会帮助你理解更多，之前对正则表达式总是非常敬畏，感觉很难上手，直到看了老姚的《JavaScript 正则表达式迷你书》，才打开了新世界的大门，有时间的朋友可以去读一下，不要被书名中的JavaScript吓到，这本书其实跟某种语言关系不大。任意门 下面讲我认为书中较为重要的点记在下面： 首先，正则是什么？正则是匹配模式，要么匹配字符，要么匹配位置。（匹配可以理解为搜索的意思） 匹配字符：一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。 其实现的方式是使用字符组。譬如[abc]，表示该字符是可以字符“a”、“b”、“c”中的任何一个，中括号里可以写任意字符，包括空格，问号等。 匹配位置：一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。 其实现的方式是使用量词。表示譬如{m,n}，表示连续出现最少m次，最多n次 其实只要明白了匹配位置的方法{m,n}和匹配字符的方法[这里可以写任意多的字符]，就可以实现99.999%的正则表达式问题。 至于其他的你看到关于正则表达式的知识都是建立在这两个基础能力之上的，要么是为了方便，创建了几个简单的写法，例如[0-5]=[012345]，又例如\\d=[0-9]，这样就不用在方括号里写太多的字符，同时也增强了可读性。 下面就介绍一些为了方便实现上面两种匹配而产生的各种简写： 1.表示字符 如果字符组里的字符特别多的话，怎么办？假如我想匹配所有的字符，总不能把所有的字符都输入到中括号内吧？ 所以，为了解决这个问题，正则表达式也可以写成这样的缩写： 比如[123456abcdefGHIJKLM]，可以写成**[1-6a-fG-M]*。用连字符”-“来省略和简写。（那么要匹配“a”、“-”、“z”这三者中任意一个字符，该怎么做呢？可以写成如下的方式：[-az]或[az-]或[a-z]。即要么放在开头，要么放在结尾，要么转义。）* **[^abc]**，表示是一个除”a”、”b”、”c”之外的任意一个字符。字符组的第一位放”^”（脱字符），表示求反的概念 \\d 就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。 \\D 就是[^0-9]。表示除数字外的任意字符。 \\w 就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。 \\W 就是[^0-9a-zA-Z_]。非单词字符。 \\s 就是[ \\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。 \\S 就是[^ \\t\\v\\n\\r\\f]。 非空白符。 . 就是[^\\n\\r\\u2028\\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。 如果要匹配任意字符怎么办？可以使用[\\d\\D]、[\\w\\W]、[\\s\\S]和[^]中任何的一个。 2.表示位置（数量） {m,} 表示至少出现m次。 {m} 等价于{m,m}，表示出现m次。 ? 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？ + 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。 *** ** 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 举例说明🌰明白了基本用法，就需要几个例子来实验一下了。如果要在目录中搜索文件夹名字中有Util的文件，而且只显示DreamReader文件夹中的结果，那我可以这样搜: 1find ./* | grep -e \".*Dream.*StringUtil\"","link":"/uncategorized/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8A%E6%89%8B/"},{"title":"每日单词计划","text":"前言工作后很难过的发现自己学了那么多年的英语正在一点点的还给老师。日常工作之余会每天记录几个遇到的生疏单词，本篇主要记录下我平时背过的单词，以便日后查询。本文不会给出释义。 由于19年的单词都是抄在纸上的，未能按天归类，20年2月26号开始按天归类。 标签示意： 这种表示易混淆词汇，无论是词型、词意还是发音上易混淆的词都会使用引用的形式包裹。 phrase 这种是短语标签 hard 这种表示是较难记住的词，或者生僻词 ·2019 delectate delectable · urban suburb outskirt rural · latent potent content contend intent intend · parliament congress · herd herb · courier career carrier · poise poison · cartoon canteen · slander slender · divident divide evident evidence · seclude include exclude · doll loll dull lull roll toll poll · vein vain · steward coward reward/award · squair squirrel · majority minority · linger malinger · counsel council console consult · crown clown crawl sprawl · achieve archive archaic · carbon carton oxygen hydrogen · sympathetic synthetic autentic · cruel crucial · fable parable · despair desperate · convene summon · resort retort · fatuous fabulous · scenario scene · devastate destroy · ambient adj. ambience n. obedient adj. obedience n. · barn storage repository warehouse · ordinate ordinary · persist insist · humility modest humble · peddle/peddler pedal petal meddle muddle saddle · pervade persuade · skeleton sketch singleton · brake break brick · bride bridge · house horse · distinct distinctive · rush rash dash · roost rooster/hen · sediment sentiment · lease/rent tease release · carpet parpenter · subtract deduct minus · patent pattern · outright thoroughly · impale pierce puncture · impetus impede impel · revolve evolve revive · clay clan claw · bolt jolt bulb bald · laud belaud laudaroty laudable applaud applause · stuff staff stiff · -scribe scribe scribble script ascribe (to) conscribe/conscript describe inscribe prescribe transcribe · phrase feel like doing (want to do) · nuance nuisance · revenge vengeance · rage page cage sage wage(salary) · jail gaol goal · explicit implicit explicate · haul hall hell hail halt · avert advert divert · shaver shiver quiver · majesty magistrate · amateur mature · collide collision crash · corpse corps · zeal zebra · deliver liver · waist waive · fault faculty · -spir perspire inspire aspire conspire respire · fanatic frantic erratic terrific · compliment complement implement complacent · mandatory laudatory migratory minatory predatory · proclaim announce · prompt promote · slash slack slander · exasperate exaggerate · rig rip ripe rape · casual casualty · budge bulge budget badge · gush gust gutter rush bush push hush · economic academic · suspicious auspicious conspicous · medal badge metal · venerage generate enervate · freight height · debt loan debit credit debris · petition position · illuminate illustrate eliminate culminate fulminate · constituent constitution · imminent immanent immigrant · potent content contend latent · owe own · liver deliver delivery deliberate · feat defeat · pump bump dump dumb lamp damp · concert cancer · instant/instantly instantaneous/instantaneously · contaminate contagious/ly/ness · revelation / reveal revolution / revolt prevalent · evaculate evaluate · contemplate temptation contempt contemporary temporary · meditation medication mitigation · puncture punctuate/punctuation punctual fluctuate/fluctuation · extinguish/extinction distinguish/distinction conspicuous · tacit tactic · culminate climax orgasm · culminate cumulate · trifle ruffle rifle · sanity sanitary · tamper hamper pamper temper damp · jagged stagger · indignant indigenous indignity · rub rob · paradox paradise parasite parallel parachute paradrop · comprise consist compose · sponge sponser · impel compel · prohibit inhibit · monopoly monotony · mitigate alleviate abbreviate deviate phrase courting death count on sb so long take time off from work Out of the blue Come back to roost be dying to do sth hard indiginous prestige lament deficit ·2020 20.2.26· wrench wretch wreck drench French · comic costic · fidelity · repel repeal compel · defer refer infer concerted · shimmer glimmer · grave gravel · insolvent insolvancy insipid · correct rectify revise · receipt p不发音 recipe e发音 · slab slate 20.2.27 allegiance alligiant allege allegation · stress distress mistress · chaste chasm · strategic (stre ti gic) · excess adj. excessive adj. exceed v. · organism orgasm · owe own owl awe · timidity humidity humility · adjacent 20.2.28 bold bald · disguise disgust · gloom bloom · category catalog · intend intent · mediate immediate intermediate · rivet pivot 20.2.29 sew sewer · dizzy dazzle fussy · peril hazard · register registrar · duplicate duplicity (Not same as repetition) · substitute supersede 20.3.1 intimate imitate · We are drasticlly, massively, manumentally different people. · slab plank slate plate · porch torch torture · handbook specification · exquisite inquisitive · swear an oath · be at fault for · prerogative provocative · fort fortnight · avert divert advert · plausible plaudit pundit bandit hermit laudable 20.3.3 stipulate stimulate simulate · resite resital · regime region · sporadic · superficial superstition · keep down put down 20.3.4 compel/compulsion propel/propulsion expel/expulsion repel/repulsion · condemn indemnity · escort estate · boast coast toast roast promise compromise 20.3.5 tumble stumble · plain plaintive · cater crater · mutter matter · misfortune mischance · paradox orthodox 20.3.6 yield field · grant grand brand · gratitude gratuity · mutter grumble · furnace furnish furniture · defiance fiance · pertain pertinent protein · relay delay · conducive · ensemble assemble resemble/resemblance/semblance · 20.3.7 jeopardy peril · ingenious homogeneous heterogeneous · ancestor antique · moderate intermediate · flush blush · feeble gaunt faint · ludicrous ridiculous exhilarate · 20.3.8 prelude preclude · manure fertilize · desirable attractive · vain vein vanity · course coarse · novice invoice · bear bare · comparative imperative · invade intrude evade · slam slum slag slug slab slub · slaughter (animal) massacre holocaust · youthful useful · dormant dormitory · tickle tackle trickle 20.3.9 ritual rival · devious vicious tedious · augment magnet · scrap crap scrape · reception receipt · sighting sightseeing · crumble grumble(mutter) · blunt blunder plunder · maize corn 20.3.10 acne pimple lump · repent resent · slender slander · nibble nipple · perish cherish · notary votary rotary · pest pester · elevate evaluate · trend tendency tenancy · breach crevice 20.3.12 ensue ensure · abridge bridge ridge · reticent sediment · lurk lure · cargo embargo embark · reimburse redeem · impetus impede · thesaurus dictionary · bleach breach preach peach · hinder tinder · molest harass protrude intrude 20.3.13 pant pants · pottery lottery · grave engrave · outset outlet · buffet Buffett · carry on carry out · tilt tile · claim exclaim declaim acclaim reclaim · glow flow blow plow · reproach approach · provision provisional improvise · germ gem 20.3.14 violet violent · cork cock · outline profile · implement tool · beside besides · wonder/wonderland/wonderful wander wound · consult counsel console reconcile ·- comment commend commence · relinquish vanquish extinguish distinguish · glimpse glance glimmer · invoke provoke revoke 20.3.15 strain stain · perimeter parameter · complex sophisticated · breed bread break brook · flap flutter · sweat sweet · trickle tickle · fort forte · piston pistol · voucher vouch · scope scoop · obligatory compulsory · buck buckle bucket · notion notation · hard prolific · induce reduce deduce · 20.3.16 incident accident incidence coincidence · ornament decoration · retort extort · phrase be at odd with phrase call off · contest context · chant merchant merchandise mercantile · saw sew · grim grimy · stroll wander · cling scaffold 20.3.17 increment excrement · oblivious obvious · victim witness · melencoly condolence condom · fever fester · craft crafy · tattoo taboo · martyr murder · alliance allegiance 20.3.18 reck reckon reckless · numerous myriad raid · permissable admissable · feasible sensible plausible · growl roar · frugle brutal cruel · gross engross · fetter fester · remit emit · elegant eloquent delinquent · 20.3.19 suitcase briefcase · meadow endow donate · assess access asset assert · restrain restraint · stew steward · jeer tease · literate illiterate (is ignorance) literature literally · pendulum perpendicular · scene obscene · 20.3.21 drain gutter sewer · compliance alliance · sculpture statue statute state status · sanitary sanity · scene obscene · fatigue frugal · slit slot · poultry paltry · floppy flock ·- teem team · pledge plague · patron patrol · stoop crouch · coed code · 20.3.22 rehearsal audition · rack rock rank · reverent relavant · perplex confuse · curtail curtain retail · escalate escalator · surge surf surface · sustainable tenable · incognito anonymous 20.3.24 seldom rarely · grind granular · vindicate Indicate dedicate · stimulate/stimulus simulate · phrase feel for · aggregate aggravate arrogant · filth fulfil · deluge inundate/inundation · puppet puppy · trill chill thrill · composite opposite · diploma diplomatic · pronounce allocate · outlying outline · hard stern · cite quote · 20.3.25 stationery stationary · overhear over here · omen oven · zest zeal · drowse drown · vigorous rigorous · protocol prototype · hard mucous 20.3.26 pit pity petty · moan groan · provisional temporary · fatal mortal · mint meant · trickle tackle tuck · rot wrought · bowel bowl · strike strive · constrain v. constraint n. · hard impromptu · prophesy v. prophecy/prophet n. · derive deprive 20.3.27 prologue monologue epilogue · aunt gaunt daunt taunt haunt vaunt flaunt · chief mischief · shed shred · study sterdy · hard cordial · ribbon gibbon · slander slender 20.3.28 transient transit · lopside lopsidedness · elbow brow bowl bowel towel · probation prohibition incubate catalyst · profile profane · shutter shatter shuttle · aspire ascribe 20.3.29 diploma dilemma · picnic panic clinic · decay stale · vanish vanquish · adapt adept inept inert · hard nostalgia · observation observance · expel evict 20.3.30 prospectus perspective prospect · indispensable dispensable dispense · sanction section · keen kin · narcotic antarctic arctic · grasp gasp gossip · damp moist · foul foil coil · phrase the pick of · scant scan · grape gape gaze graze · soluble solvable salute/salution · riot turmoil · I’m impotent Omnipotent 20.3.31 ascent ascend accent assent scent · ordeal torture · prentice apprentice apparatus · spite spit · descent/descend decent · arena antenna · circus circuit · 20.4.1 apparatus apparition · tropic topic · levy navy · anguish anguine · genuine authentic · kettle · foremost forefront · graze bruise abrase/abrasion 20.4.2 flick flicker · paraphrase paragraph · buoyant buoyancy · granary granular · conscience conscious · scalp scalpal · sauce saucer · pier pierce · 20.4.3· assiduous arduous · depict narrative · decapitate dilapidate · yarn yard yacht · marsh mire moor swamp · lotion potion · rage cage sage wage · sever fever lever · dispute dissipate 20.4.4 surveillance · suspence suspend · diverge verge · fraction fracture · crumble crumple rumple · mortality morality · 20.4.5 wine wing · antonym synonym · estate esteem · din dean · rudeness ruthless · advocate advertise · step steep · scrupulous meticulous · intuition institution · wane cane lane sane mane · 20.4.6· mercy mercury · etiquette netiquette · subordinate superior · prevail reveal · scotch scorch · circulate regulate · recline decline incline · enzyme catalyst · anonymous unanimous 20.4.7 sarcasm coerce · surplus surpass · arena antenna · salvage savage ravage · excess exceed excel extol · lava lavatory · moth mother · refrigerate fringe · vault fault foul · rein rain · lank slender pliable 20.4.8 stride strike stroke · trait traitor strait · piss off pass off · feline cat · sustenance sustain · pollute pollution pollinate pollination · tuck tug · treatise thesis · 20.4.9 heir air · subside subsidy · rip reap rape · quench extinguish · 20.4.10 pulp jam · situate locate · mediocre coerce · magnate magnet · torrent turbulence · pirate/piracy private/privacy · 20.4.11 agony · bureau burial [e] · curve curse · brow brew · turf · keep at keep sb up · blur obscure · manacle · vigilant · plump plum plummet plumb · ambition ambiguity · delicate deliberate · scatter disperse · wink brink precipice stiff cliff TO BE CONTINUE","link":"/uncategorized/%E6%AF%8F%E6%97%A5%E5%8D%95%E8%AF%8D%E8%AE%A1%E5%88%92/"},{"title":"编程题之数串","text":"题目描述 设有n个正整数，将他们连接成一排，组成一个最大的多位整数。 如:n=3时，3个整数13,312,343,连成的最大整数为34331213。 如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。 输入描述: 有多组测试样例，每组测试样例包含两行，第一行为一个整数N（N&lt;=100），第二行包含N个数(每个数不超过1000，空格分开)。 输出描述: 每组数据输出一个表示最大的整数。 1234567891011示例1输入212 12347 13 4 246输出123127424613 解答首先，本题可以理解为对N个数进行排序，只不过排序的标准不是数值的大小，而是两个字符串组合到一起转化成整形后的数值大小，所以只需要随便采用一种排序方法，在比较大小时改成比较字符串组合的大小就行。 话不多说，上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Scanner;/** * Created by kevin on 17-9-5. * Mail: chewenkaich@gmail.com */public class Main { public static void main(String[] args) { // 获取输入 Scanner in = new Scanner(System.in); int count = Integer.valueOf(in.nextLine().trim()); if (count &gt; 100) return; String inStr = in.nextLine().trim(); String[] dataStr = inStr.split(\" \"); int[] data = new int[dataStr.length]; for (int i = 0; i &lt; dataStr.length; i++) { data[i] = Integer.valueOf(dataStr[i]); } // 此处为一个冒泡排序，也可以使用其他快排，归并等其他高效排序方法 for (int pass = data.length - 1; pass &gt;= 0; pass--) { for (int i = 0; i &lt; pass; i++) { if (!is1stBiggerThan2nd(data[i], data[i + 1])) { // 第i个数“小于”第i+1个数 int tem = data[i + 1]; data[i + 1] = data[i]; data[i] = tem; } } } // 输出结果 String result = \"\"; for (int each : data) { result += String.valueOf(each); } System.out.println(result); } /** * 从两个整数组合起来较大时，其中的第一个整数，例如， * a=3489, b=3423 * 因为a组合b = 34893423 &gt; b组合a = 34233489，所以返回a * * @param a * @param b * @return true, a+b &gt; b+a; false, a+b &lt; b+a */ static boolean is1stBiggerThan2nd(Integer a, Integer b) { if (Integer.valueOf(String.valueOf(a) + String.valueOf(b)) &gt; Integer.valueOf(String.valueOf(b) + String.valueOf(a))) return true; else return false; }} 最终程序运行结果如下 运行时间：169ms 占用内存：13040k 如果有任何问题，欢迎指正。","link":"/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8B%E6%95%B0%E4%B8%B2/"},{"title":"Mac上双硬盘导致的盘符变化和权限问题引起的Vbox虚拟机启动失败","text":"最近在小米笔记本上安装了黑苹果，从Arch Linux上转到了MacOS High Sierra。说实话，虽然在操作上很多东西还不是很习惯，但是MacOS丰富的软件和漂亮的界面以及合理的逻辑非常讨人喜欢。 很快，我也遇到了一些问题，首先是经常用到的VirtualBox虚拟机启动物理硬盘上的Windows时遇到的问题： 安装了双硬盘的笔记本在启动时设备符号是变化的，有时候是/dev/disk0，有时候则是/dev/disk1，导致保存的镜像文件（vmdk文件）需要重新生成。 Mac下只要重新挂载Windows分区所在的硬盘，权限也要重新授权。否则报错： 1234VBoxManage: error: VMDK: could not open raw disk file '/dev/disk2' VBoxManage: error: Error code VERR_RESOURCE_BUSY at /Users/vbox/tinderbox/4.3-mac-rel/src/VBox/Storage/VMDK.cpp(3390) in function int vmdkCreateRawImage(VMDKIMAGE*, VBOXHDDRAW*, uint64_t)VBoxManage: error: Cannot create the raw disk VMDK: VERR_RESOURCE_BUSYVBoxManage: error: The raw disk vmdk file was not created 索性写了一个简单的shell脚本，直接完成授权和生成vmdk文件的工作，顺便通过VBoxManager启动虚拟机。 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashecho “开始更改虚拟机权限…”;# 根据diskutil list的输出，获取Windows所在磁盘的名称diskpos=\"`diskutil list | grep 'Microsoft Basic Data Windows'`\";length=${#diskpos};disknumber=${diskpos:`expr $length - 3`:1};disk_name=\"disk${disknumber}\";# 卸载Windows所在磁盘diskutil umountDisk $disk_name;# 检查是否卸载成功if [ $? -ne 0 ]then echo \"磁盘被占用，请关闭此磁盘打开的文件后重试\"; exit;fi# 更改权限sudo chown $USER \"/dev/$disk_name\";# ENDEcho \"更改权限完成，开始启动虚拟机...\";# 定义VirtualBox中建立好的系统的名字sys_name=\"Windows\"# 解除原来在SATA的PORT 0上的HDD媒体文件VBoxManage storageattach $sys_name --storagectl SATA --port 0 --type hdd --medium none;# 关联新的HDD媒体文件到SATA的PORT 0上VBoxManage storageattach $sys_name --storagectl SATA --port 0 --type hdd --medium ~/VirtualBox\\ VMs/disk${disknumber}.vmdk# 启动虚拟机VBoxManage startvm Windows 参考资料：关于MAC下用VirtualBox启动Windows时报错“VERR_RESOURCE_BUSY”的问题 https://apple.stackexchange.com/questions/165153/how-do-i-install-mavericks-onto-external-hd-but-from-inside-virtualbox 链接 VBoxManager的使用参考这里 https://www.shennongmin.org/?p=1993#comment-42 链接 VBoxManager官网文档 https://www.virtualbox.org/manual/ch08.html#vboxmanage-storageattach 链接 macOS安装教程兼小米Pro安装过程记录 https://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html 链接 小米笔记本Pro安装10.13随手记及EFI分享 https://blog.daliansky.net/XiaoMiPro-notebook-Installation-10.13-readily-remember-and-share-EFI.html 链接","link":"/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/mac%E4%B8%8A%E5%8F%8C%E7%A1%AC%E7%9B%98%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%98%E7%AC%A6%E5%8F%98%E5%8C%96%E5%92%8C%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%E5%BC%95%E8%B5%B7%E7%9A%84vbox%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/"},{"title":"记一次overloadaggressively造成的崩溃","text":"将Kotlin版本从1.1.2-4升级到1.3.11后，发现打的release包开机就会崩溃：崩溃日志为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546java.lang.RuntimeException: Unable to instantiate application com.tencent.sigma.patch.HotPatchApplication: java.lang.ClassNotFoundException: Didn't find class \"com.tencent.sigma.patch.HotPatchApplication\" on path: DexPathList[[zip file \"/data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/base.apk\"],nativeLibraryDirectories=[/data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/lib/arm, /data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/base.apk!/lib/armeabi, /system/lib, /vendor/lib]] at android.app.LoadedApk.makeApplication(LoadedApk.java:993) at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5801) at android.app.ActivityThread.-wrap1(Unknown Source:0) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1683) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:173) at android.app.ActivityThread.main(ActivityThread.java:6650) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:818) Caused by: java.lang.ClassNotFoundException: Didn't find class \"com.tencent.sigma.patch.HotPatchApplication\" on path: DexPathList[[zip file \"/data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/base.apk\"],nativeLibraryDirectories=[/data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/lib/arm, /data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/base.apk!/lib/armeabi, /system/lib, /vendor/lib]] at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:125) at java.lang.ClassLoader.loadClass(ClassLoader.java:379) at java.lang.ClassLoader.loadClass(ClassLoader.java:312) at android.app.Instrumentation.newApplication(Instrumentation.java:1088) at android.app.LoadedApk.makeApplication(LoadedApk.java:987) at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5801)&nbsp; at android.app.ActivityThread.-wrap1(Unknown Source:0)&nbsp; at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1683)&nbsp; at android.os.Handler.dispatchMessage(Handler.java:106)&nbsp; at android.os.Looper.loop(Looper.java:173)&nbsp; at android.app.ActivityThread.main(ActivityThread.java:6650)&nbsp; at java.lang.reflect.Method.invoke(Native Method)&nbsp; at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)&nbsp; at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:818)&nbsp; Suppressed: java.io.IOException: Failed to open dex files from /data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/base.apk because: Failure to verify dex file '/data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/base.apk': Out-of-order annotation_element name_idx: 7150 then 7150 at dalvik.system.DexFile.openDexFileNative(Native Method) at dalvik.system.DexFile.openDexFile(DexFile.java:353) at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:100) at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:74) at dalvik.system.DexPathList.loadDexFile(DexPathList.java:374) at dalvik.system.DexPathList.makeDexElements(DexPathList.java:337) at dalvik.system.DexPathList.&lt;init&gt;(DexPathList.java:157) at dalvik.system.BaseDexClassLoader.&lt;init&gt;(BaseDexClassLoader.java:65) at dalvik.system.PathClassLoader.&lt;init&gt;(PathClassLoader.java:64) at com.android.internal.os.ClassLoaderFactory.createClassLoader(ClassLoaderFactory.java:73) at com.android.internal.os.ClassLoaderFactory.createClassLoader(ClassLoaderFactory.java:88) at android.app.ApplicationLoaders.getClassLoader(ApplicationLoaders.java:69) at android.app.ApplicationLoaders.getClassLoader(ApplicationLoaders.java:35) at android.app.LoadedApk.createOrUpdateClassLoaderLocked(LoadedApk.java:695) at android.app.LoadedApk.getClassLoader(LoadedApk.java:729) at android.app.LoadedApk.getResources(LoadedApk.java:956) at android.app.ContextImpl.createAppContext(ContextImpl.java:2282) at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5723) ... 8 more 乍一看，以为是HotPatchApplication被混淆的原因导致Class Not Found，于是尝试keep住HotPatchApplication这个类，但是发现问题依旧。于是又怀疑是前不久升级gradle对分包造成了影响，对apk中的dex文件进行分析，发现HotPatchApplication这个类稳稳的躺在第一个dex文件中。 后来又进行了以下的尝试： ​ 1.尝试按顺序更改Kotlin版本，最后，当Kotlin版本为1.3.0时，发现问题出现了。 ​ 2.另一个线索是当我打开Proguard时，那就是minifyEnable true，崩溃就出现了。 经过以上排查，基本确定了问题出在Kotlin和混淆的身上。最后发现上述日志中有一行： 1Suppressed: java.io.IOException: Failed to open dex files from /data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/base.apk because: Failure to verify dex file '/data/app/com.tencent.dreamreader-P2-qUIVdDrdEOhONvRwOtw==/base.apk': Out-of-order annotation_element name_idx: 7150 then 7150 这个报错是第一次见到，上网搜了下，最终定位在混淆时的一个参数身上：-overloadaggressively ProGuard官网解释： -overloadaggressively Specifies to apply aggressive overloading while obfuscating. Multiple fields and methods can then get the same names, as long as their arguments and return types are different, as required by Java bytecode (not just their arguments, as required by the Java language). This option can make the processed code even smaller (and less comprehensible). Only applicable when obfuscating. 可以看出，开启该选项可能把不同的方法或者变量混淆成相同的名字，这样会尽可能的减小代码体积。但是由于过于激进，造成了dex文件中有重复annotation_element，这个问题在编译和打包时并不会报错，只有在开启软件时才会发现。 至于为什么升级了Kotlin才有这个问题，猜测原因是新版本的kotlin中加入了Keep注释与Java的Keep注释同名造成的。 解决办法： 去掉混淆文件（proguard.txt）中的-overloadaggressively 参考： https://stackoverflow.com/questions/56458360/app-crashed-when-r8-enabled-with-existing-proguard-settings https://issuetracker.google.com/issues/129241209#comment11 https://stackoverflow.com/questions/51948250/failure-to-verify-dex-file-out-of-order-annotation-element-name-idx","link":"/uncategorized/%E8%AE%B0%E4%B8%80%E6%AC%A1overloadaggressively%E9%80%A0%E6%88%90%E7%9A%84%E5%B4%A9%E6%BA%83/"},{"title":"DisqusJS Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/disqusjs-comment-plugin/"},{"title":"Disqus Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/disqus-comment-plugin/"},{"title":"Utterances Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/utterances-comment-plugin/"},{"title":"Gitalk Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/gitalk-comment-plugin/"},{"title":"Facebook Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno. Please turn off your ad blockers if you do not see the comment section.","link":"/uncategorized/facebook-comment-plugin/"},{"title":"踩坑-复用RemoteView导致内存泄漏总结","text":"复用RemoteView导致内存泄漏总结关于RemoteViewRemoteView是一个提供跨进程控制的View，主要用在通知栏或者小部件的开发上。例如音乐类APP自定义的通知栏样式就是通过RemoteView实现的。如果你之前没有听说过RemoteView，可以在这里简单了解一下： https://www.jianshu.com/p/23041852bd85 RemoteView中可以使用的布局和控件是受限制的，能用的布局有： AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper 可以用的控件有: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView 遇到的问题最近开发了一个音乐类的App，播放音乐时会在通知栏常驻一个自定义样式的通知，其中通知栏有一个头像是通过setImageViewBitmap(int viewId, Bitmap bitmap)方法进行设置的： 123456RemoteViews mRemoteView; // 全局变量mRemoteView = new RemoteViews(Application.getInstance().getPackageName(), resId);// 每次调用setImageViewBitmap来更新通知栏的头像mRemoteView.setImageViewBitmap(R.id.cover, bitmap); 后来发现如果App连续放歌在3个小时左右时就会OOM崩掉，通过Profile检查内存后，发现是头像的bitmap没有销毁导致的，但是这里的bitmap对象每次使用完都会recycle掉，为什么还会内存泄漏呢？经过一番排查，发现是使用同一个RemoteVIew对象setImageViewBitmap(R.id.cover, bitmap)导致的。 在RemoteView的源码中我们可以看到一个mActions变量，这是一个Action的列表： 12345/** * An array of actions to perform on the view tree once it has been * inflated */private ArrayList&lt;Action&gt; mActions; 而Action是其内部定义的一个可序列化的类: 1private abstract static class Action implements Parcelable 通过跟踪setImageViewBitmap(int viewId, Bitmap bitmap)中bitmap的去向，发现最终调用了setBitmap()方法: 12345678910111213141516171819202122232425public void setBitmap(int viewId, String methodName, Bitmap value) { addAction(new BitmapReflectionAction(viewId, methodName, value));}private class BitmapReflectionAction extends Action { int bitmapId; Bitmap bitmap; String methodName; BitmapReflectionAction(int viewId, String methodName, Bitmap bitmap) { this.bitmap = bitmap; ... } ... @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(TAG); dest.writeInt(viewId); dest.writeString(methodName); dest.writeInt(bitmapId); } ... } 可以看出，每次setImageViewBitmap()，都会将Bitmap做成一个BitmapReflectionAction，并添加到mActions列表里，这里的BitmapReflectionAction是继承Action的一个可序列化的类，Bitmap在里面作为被序列化成了一组值最终存到了mActions列表中。在源码中，mActions列表只看到有添加操作，并没有看到remove或者clear操作，导致了内存泄漏。 解决不要复用RemoteView，更新通知栏icon时，new一个新的RemoteView给NotificationCompat.Builder 参考 So internally RemoteViews is simply a set of actions that are “serialized” and sent to another process. Each time you make a call to something like setDouble(), you’re adding an additional action to RemoteViews’ internal list. Because there isn’t a way of clearing these actions from a RemoteViews object, all of your successive setImageViewBitmap() calls, along with their Bitmaps, remain in the internal list, and are actually “serialized” and applied each time your send it. :( In this case it’s best to just create a new RemoteViews object every time. https://github.com/rojdes/AngryDict/blob/master/app/src/main/java/me/rds/angrydictionary/widget/BinaryClockWidget.java https://blog.csdn.net/u013989732/article/details/78501462","link":"/Android/%E8%B8%A9%E5%9D%91-%E5%A4%8D%E7%94%A8remoteview%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"Waline Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/waline-comment-plugin/"},{"title":"Valine Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno. A vulnerability has been found in Valine that the comment service exposes IP addresses of all commenters (xCss/Valine#336). Please use alternative comment services until this issue has been fixed.","link":"/uncategorized/valine-comment-plugin/"},{"title":"Google CSE Search Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/google-cse-search-plugin/"},{"title":"AddToAny Share Buttons","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/addtoany-share-buttons/"},{"title":"Algolia Search Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/algolia-search-plugin/"},{"title":"Share.js Share Buttons","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/share-js-share-buttons/"},{"title":"ShareThis Share Buttons","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/sharethis-share-buttons/"},{"title":"AddThis Share Buttons","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno. Please turn off your ad blockers if you do not see the buttons.","link":"/uncategorized/addthis-share-buttons/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Study","slug":"Study","link":"/tags/Study/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"报告","slug":"报告","link":"/tags/%E6%8A%A5%E5%91%8A/"},{"name":"日常总结","slug":"日常总结","link":"/tags/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"},{"name":"Andoird","slug":"Andoird","link":"/tags/Andoird/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"VIM","slug":"VIM","link":"/tags/VIM/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"StarDict","slug":"StarDict","link":"/tags/StarDict/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"抽样监督管理系统","slug":"抽样监督管理系统","link":"/tags/%E6%8A%BD%E6%A0%B7%E7%9B%91%E7%9D%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"牛客","slug":"牛客","link":"/tags/%E7%89%9B%E5%AE%A2/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"VirtualBox","slug":"VirtualBox","link":"/tags/VirtualBox/"},{"name":"日常记录","slug":"日常记录","link":"/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"Demo","slug":"Demo","link":"/tags/Demo/"}],"categories":[{"name":"日常记录","slug":"日常记录","link":"/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"日常总结","slug":"日常总结","link":"/categories/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"日常汇报","slug":"日常汇报","link":"/categories/%E6%97%A5%E5%B8%B8%E6%B1%87%E6%8A%A5/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"数据结构","slug":"面试/数据结构","link":"/categories/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Android","slug":"Android","link":"/categories/Android/"}]}